# Заметки на полях: Изолируем Lua окружение в C++ приложении.
tags: c++, lua, gamedev, sol2

## Введение
Для начала накинем немного контекста.
- Во-первых, в качестве C++ хоста у нас выступает игровой движок, где скриптовый язык нужен для конфигов, логики, модов и вот этого вот всего.
- Во-вторых, нужна возможность запуска сторонних, написанных не нами (читай непроверенных и потенциально небезопасных) скриптов.
- В-третьих, исходя из вышеобозначенного, очень желательно свести к минимуму возможности нашкодить, со стороны особенно любознательных пользователей, очень творческих мододелов и просто мамкиных кулхацкеров;
- В-четвёртых, берём как данность, что автор этих строк от природы откровенно ленив и, поэтому, по максимуму стараемся использовать уже готовые решения.

Опустим рассуждения о достоинствах и недостатках Lua в качестве скриптового языка, а так же обзор возможных вариантов его подключения к нашему приложению - для этого есть уйма статей, написанных такими корифеями, что я даже смысла не вижу залезать на эту поляну. А, просто, возьмём как данность, что выбор в итоге остановили на:
- Lua 5.1/LuaJIT: Версии после 5.1 показывают деградацию по скорости выполнения _(а у нас же геймдев)_, а JIT-версия, в принципе остановилась в своём развитии на этапе 5.1;
- Для подключения используем `sol2` - невероятно вкусная библиотека, которая просто до неприличия упрощает взаимодействие с Lua. Опять же, без ущерба скорости _(ну геймдев же, ну)_;
- Ну и C++20. Просто потому, что есть такая возможность. Впрочем, всё, описанное ниже, вполне реализуемо и на более взрослых версиях стандарта.


## Реализация

Для выполнения Lua-кода из нашего приложения необходимо создать для него окружение - фактически виртуальную машину, содержащую всё необходимое для запуска скриптов - стек, глобальные переменные, таблицы и функции, а также аллокатор и сборщик мусора. В терминологии Lua это называется **_state_** (состояние).

Создание всего этого - задача, конечно, довольно нетривиальная. 
<details>
<summary> И, в нашем случае, решается через...</summary>

Добавление двух строк )
```cpp
#include <sol/sol.hpp>

sol::state lua;
```
</details>

-----

Собственно, уже на этом этапе в нашем распоряжении - синтаксис и базовая семантика, циклы и операторы ветвления, логика и арифметика, таблицы и возможность определять свои функции.

Чего с головой хватит для описания большей части данных, что нам может понадобиться - юниты, инвентарь, диалоги, карты, описание уровней, UI, графика, звуки и чего только не.

```lua
-- Lua
-- config_screen.lua

local screen = {
    width = 1280,
    height = 720,
    presets = {
        ["HD"]  = {1280, 720},
        ["FHD"] = {1920, 1080},
        ["4K"]  = {3840, 2160},
        default = "HD"
    }
}
function getScreenPreset(preset)
    local presets = screen.presets
    return presets[preset] or presets[presets.default]
end

return screen
```
```cpp
// Cpp
auto screenCfg = lua.script_file("config_screen.lua");

// доступ к элементам Lua-таблицы по ключу
int width = screenCfg["width"];
int height = screenCfg["height"];

std::cout << std::format("Configured screen resolution: {}x{}\n", width, height);
// --> Configured screen resolution: 1280x720

// можем вызывать функции объявленные в Lua
auto preset = lua["getScreenPreset"]("FHD");

// Доступ по индексу
width = preset[1]; // И да, индексация в Lua начинается c 1
height = preset[2];

std::cout << std::format("FHD resolution: {}x{}\n", width, height);
// --> FHD resolution: 1920x1080
```
А, реализовав недостающий функционал на стороне C++, и, пробросив его в Lua, можно уже замахиваться на игровую логику.
```cpp
// Cpp
namespace math
{
    int add(int a, int b) { return a + b; };
}

auto api = lua.create_table();

api["add"] = math::add;
api["sub"] = [](int a, int b) { return a - b; };

lua["engineAPI"] = api;

lua.script_file("script.lua");

int a = lua["a"];
std::cout << std::format("a:{}, b:{}\n", a, lua["b"].as<int>());
// --> a:30, b:-10
```
```lua
-- Lua
-- script.lua

a = engineAPI.add(10, 20)
b = engineAPI.sub(10, 20)
```
И на этом можно было бы уже заканчивать.

Но.

У нас уже не мало доступного функционала, а вот возможностей чувствительно нашкодить в скриптах ещё не очень _(Кстати, какие варианты приходят в голову? В комментах писать не надо - а то подглянут ещё)_. Я  бы, всё-таки, расширил пространство для манёвра любителям, скажем так, нестандартных решений - ну так, чисто ради подогрева интереса. Это во-первых.

Во-вторых, у нас, в самом начале, в исходных данных была обозначена природная лень. Следовательно, рожать велосипед самостоятельно повторяя функционал стандартных библиотек - ну серьёзно?

Ну а в-третьих, это было бы слишком просто и смысла даже начинать  данную заметку не было. Но если посмотреть на ползунок прокрутки справа, то текста там там ещё порядком. Поэтому придётся продолжать. 


## Стандартные Lua библиотеки
Для начала коротко пробежимся по тому, что же они нам предлагают - а то, может, действительно не стоит заморачиваться?


| Библиотека | Назначение | Функционал / Описание |
|-------------|-------------|------------------------|
| **base** | Базовые возможности языка | Основные конструкции Lua: работа с типами, проверка и преобразование значений, обработка ошибок, итерация по таблицам, **выполнение кода из строк или файлов** и базовые средства метапрограммирования. |
| **package** | Система модулей | **Организация и загрузка Lua- и C-модулей, подключенние библиотек.** |
| **string** | Работа со строками | Изменение, поиск и шаблонное сопоставление строк, конкатенация, форматирование, преобразование регистра. |
| **table** | Манипуляции с таблицами | Работа с таблицами: сортировка, объединение, вставка, удаление, копирование, преобразование таблиц в строки и обратно. |
| **math** | Математика и случайность | Арифметические, тригонометрические и логарифмические функции, округление, генерация случайных чисел, операции с целыми. |
| **io** | Ввод-вывод | Работа с файлами и стандартными потоками: **открытие, чтение, запись, построчная обработка**, управление буферами. |
| **os** | Доступ к функциям ОС | Работа со временем, датой, **окружением, файлами и системными командами. Позволяет взаимодействовать с внешней средой.** |
| **coroutine** | Кооперативная многозадачность | Создание и управление корутинами: приостановка и возобновление выполнения, реализация последовательных сценариев. |
| **debug** | Отладка | **Доступ к стеку вызовов, локальным переменным и функциям. Используется для профайлинга и инструментов разработки.** |


Из полезных есть ещё **utf8** и **bit32**. Первая, как ни странно, для работы с кодировкой UTF8, вторая - реализация битовых операций. Но их завезли уже после Lua 5.1, поэтому игнорируем. Да, битовых операций в 5.1 нет. Совсем.

Даже беглого просмотра достаточно чтобы понять - брать надо. Но с осторожностью - в таблице в описании **жирным** выделен небезопасный функционал.

Если же [копнуть чуть глубже](http://lua-users.org/wiki/SandBoxes), то вырисовывается вполне себе чёткая картина - для части библиотек содержимое придётся загружать выборочно, а для некоторых - даже их название вслух произносить небезопасно. Поэтому последние просто игнорируем, но если уж совсем приспичит - их функционал придётся реализовывать самостоятельно _(тот же доступ к файловой системе, можно ограничить только на чтение, и только в пределах разрешённых путей)_.

Теперь придётся чуть подробнее остановиться на том, что, собственно, представляет из себя загрузка библиотек в Lua.

<details>
<summary> Но начнем мы, как ни странно, с таблиц. </summary>

*Можно смело пропустить, если в курсе внутренней кухни Lua.

В Lua таблицы - это единый и универсальный механизм данных и структурирования, на котором, фактически, строится вообще весь язык. Они могут хранить значения любого типа - числа, строки, другие таблицы и **функции**. И не просто могут - вообще все переменные, функции, библиотеки и модули являются именно элементами таблиц.

Тип у Lua таблиц является ссылочным - т.е. когда мы присваиваем переменной или передаём в функцию какую-нибудь таблицу, копирования не происходит - присваивается и передаётся только ссылка. Если такая переменная выходит из области видимости или ей присваивается `nil` - ссылка обнуляется. А когда ссылок на нашу таблицу вообще не остаётся, она с чистой совестью выпиливается сборщиком мусора. Очевидно, что у нас должна быть какая-то главная таблица, не удаляемая сборщиком и в которой мы сможем создавать ссылки на новые. 

И вот тут, создатели языка подошли с фантазией. Они сделали её неявной - т.е. она есть, и вы можете даже обратиться к ней по имени, но это совсем не обязательно. Вы можете спокойно писать на Lua, даже не подозревая о её существовании. Конечно, есть несколько сценариев, когда явное обращения, таки, потребуется - но это уже для тех, кто действительно знает что делает.

Ещё раз: основная точка входа в Lua - скрыта от пользователя, даёт  работать с языком даже не зная о месте её нахождения, а явное обращение к ней в умелых руках позволяет делать нетривиальные вещи.

Есть идеи для названия?
</details>

Её величество **`_G`**. Это переменная, содержащая ссылку на предопределённую таблицу глобального окружения. И абсолютно все глобальные переменные и функции являются полями этой таблицы.
```lua
-- Lua
x = 42
print(x)       --> 42
print(_G.x)    --> 42
_G.print(_G.x) --> 42
```

И именно в `_G` загружаются библиотеки, которые представляют из себя ни что иное, как просто таблицы с функциями _(упростил, да)_. Создаётся глобальная переменная и в неё кладётся ссылка на соответствующую таблицу. Всё.

```cpp
// Cpp
sol::state lua;

// Собственно, загрузка библиотек
lua.open_libraries(sol::lib::base, sol::lib::math);

lua.script(R"(
    print("#1 " .. math.max(10, 42, -1))
    print("#2 " .. _G.math.max(10, 42, -1))
)");
// --> #1 42
// --> #2 42
```
За редким исключением правда - например, функции из `base` кладутся прямо в глобальную область видимости *(тот же `print`, а не `base.print` из примера выше)*.

Дальше, в Lua нет механизма частичной загрузки библиотек. Первое, что приходит на ум:
```cpp
lua.open_libraries(sol::lib::os);

// просто обнулить опасные функции
os["execute"] = sol::nil
os["remove"] = sol::nil
...
```

Но есть более гибкий вариант - механизм подмены таблицы глобального окружения, который позволяет запускать код в окружении, изолированном от основного Lua-стейта - в песочнице.

```cpp
lua::state lua;
lua::environment sandox(lua.state, sol::create);
sandbox["_G"] = sandbox;

lua.script_file("script.lua", sandbox);
```
И вот в неё-то мы уже можем спокойно скопировать только те части библиотек, которые посчитаем нужными. Не беспокоясь о том, что библиотеки могут содержать какие-либо неявные потенциально небезопасные поля _(Lua позволяет обойти все поля таблицы простым перебором, даже не зная их названия. `_G` это, кстати, тоже касается)_.

```cpp
lua::state lua;
lua::environment sandox(lua.state, sol::create);
sandbox["_G"] = sandbox;

auto checkWhere = R"(
    if print then
        print (whereAmI)
    else
        houston()
    end
)";

auto houston = [&]() {
    std::cout << "Houston, we have a problem.\n";
};

lua["whereAmI"] = "In a Lua state";
lua["houston"] = houston;

sandbox["whereAmI"] = "In a sandbox";
sandbox["houston"] = houston;

lua.script(checkWhere); // --> Houston, we have a problem.

// Теперь загружаем библиотеку
lua.open_libraries(sol::lib::base);

lua.script(checkWhere); // --> In a Lua state


// Здесь уже явно указываем окружение, в котором нужно выполнить скрипт
lua.script(checkWhere, sandbox); // --> Houston, we have a problem.
                                 // т.к. в песочнице print == nil - мы же его не загружали

sandbox["print"] = lua["print"];
lua.script(checkWhere, sandbox); // --> In a sandbox
```
Кроме того, это дополнительно открывает нам несколько возможностей - например, на одном Lua-стейте делать сразу несколько независимых песочниц - хоть по отдельной на каждый запускаемый скрипт. Что существенно облегчает нам задачу, по реализации обмена данными между песочницами. При сбросе песочницы _(например перезапуск миссии)_ не нужно подгружать все библиотеки заново - мы просто заменяем таблицу-окружение на новую и копируем в неё разрешённые элементы. В конце концов, в случае необходимости, для доверенных скриптов в нашем распоряжении оказывается ещё и полнофункциональная версия Lua. Последнее можно использовать с осторожностью и оговорками, но тем не менее, возможность такая есть.



---

- **base** - мастхэв, но вот функционал запуска кода на выполнение придётся взять на себя и реализовать безопасные замены самостоятельно.
- **table**, **string** - однозначно забираем.
- **math** - случайную генерацию лучше оставить на стороне хоста _(для мультиплеера она обычно должна быть синхронизирована для всех клиентов)_, а остальное лишним точно не будет.
- **os** - оставляем только функции для доступа ко времени.
- **coroutine** - почему бы и да! Пускай будет.
- **debug** - вообще без вариантов, здесь я бы её даже палкой трогать не стал.
- **io** - действительно, почему бы не дать сомнительным скриптам доступ к файловой системе?


## Что пока не охвачено данной реализацией.

1. Защита от зависаний на стороне lua-скриптов: решается через хуки и таймауты - если скрипт выполняется дольше чем разрешено таймаутом, то скрипт просто прибивается. Да, это не решает проблему неработоспособности скрипта, но, по крайней мере, даёт возможность нашему движку отработать ошибку и работать дальше, не вылетев из-за кривого мода/карты. 
2. Защита от отжора памяти.
3. Механизм контроля целостности доверенных скриптов - например, скриптов, поставляемых нами самими. Со скриптами модов пользователь может делать что угодно, но для гарантированной работоспособности движка его скрипты трогать не стоит.
4. Hotreload.
