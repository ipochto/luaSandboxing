# Заметки на полях: Изолируем Lua окружение в C++ приложении.
tags: c++, lua, gamedev, sol2

Скриптовые языки уже давно и прочно заняли свою нишу в игрострое — они существенно упрощают описание игровой логики, уровней, ресурсов, диалогов, квестов, UI и чего только не. Что позволяет отдать эти задачи целиком и полностью в творческие руки гейм-/левел-/прочих-дизайнеров и других членов команды, которым не нужно обладать знаниями в том же C++. Разделение ответственности, ускорение разработки, облегчение моддинга ~~возможность, по завершению разработки самого движка, вышвырнуть программистов на мороз и стричь купоны на бесконечных дополнениях~~ — в общем, одни только плюсы. Да? 

Да.

А ещё дыры в безопасности и уйма путей уронить стабильность.

В замечательном цикле статей "Game++" от @dalerank, а если быть конкретней, то в [Game++. while (!game(over))](https://habr.com/ru/articles/907146/) озвучена следующая мысль про скрипты в игровых движках, как раз на эту тему:

> ***... на удивление, [скрипты — ] это про безопасность***  
Скрипты обычно запускаются в изолированной среде. Это значит, что если моддер написал что-то странное — он сломает только свою миссию, а не всю игру. Можно ограничить доступ скриптам: дать им возможность работать только с теми объектами, которые тебе нужны. Настроить лимиты, интерпретировать исключения, и в крайнем случае — просто не запускать подозрительное. В плюсах такой гибкости не получишь. Там любой кривой плагин — это потенциальный краш.  

Т.е. лечится.

## Но, блин, КАК?

К сожалению, ответ на этот вопрос выходил далеко за рамки той статьи, поэтому пришлось разбираться самому.

## Постановка задачи
Для начала накинем немного контекста:
- Во-первых, в качестве C++ хоста у нас выступает игровой движок, где скриптовый язык нужен для конфигов, логики, модов и вот этого вот всего.
- Во-вторых, нужна возможность запуска сторонних, написанных не нами (читай: непроверенных и потенциально небезопасных) скриптов.
- В-третьих, исходя из выше обозначенного, очень желательно свести к минимуму возможности нашкодить со стороны особенно любознательных пользователей, очень творческих мододелов и просто мамкиных кулхацкеров.
- В-четвёртых, берём как данность, что автор этих строк от природы откровенно ленив, и поэтому по максимуму стараемся использовать уже готовые решения.

Опустим рассуждения о достоинствах и недостатках Lua в качестве скриптового языка, а также обзор возможных вариантов его подключения к нашему приложению — для этого есть уйма статей, написанных такими корифеями, что я даже смысла не вижу залезать на эту поляну. Просто, возьмём как данность, что выбор в итоге остановили на:
- Lua 5.1/LuaJIT: Ибо JIT-версия покрывает все остальные версии по производительности. Кратно _(а у нас же геймдев)_. Но, к сожалению, она в принципе остановилась на этапе Lua 5.1, поэтому ориентироваться будем на синтаксис и набор библиотек, актуальный на тот момент. Тем не менее жёстко к LuaJIT-специфичным нюансам не привязываемся и стараемся все решения делать максимально универсальными, ну или требующими минимальных доработок.
- Для подключения используем `sol2` — невероятно вкусная библиотека, которая просто до неприличия упрощает взаимодействие с Lua. Опять же, без ущерба скорости _(ну геймдев же, ну)_;
- Ну и C++20. Просто потому, что есть такая возможность. Впрочем, всё, описанное ниже, вполне реализуемо и на более взрослых версиях стандарта.

## По пути наименьшего сопротивления

Для выполнения Lua-кода из нашего приложения необходимо создать для него окружение — фактически виртуальную машину, содержащую всё необходимое для запуска скриптов: стек, глобальные переменные, таблицы и функции, а также аллокатор и сборщик мусора. В терминологии Lua это называется **_state_** (состояние).

Создание всего этого — задача, конечно, довольно нетривиальная. 
<details>
<summary> И, в нашем случае, решается через... [развернуть]</summary>

```cpp
// Добавление аж двух строк )
#include <sol/sol.hpp>
sol::state lua;
```
</details>

-----

Собственно, уже на этом этапе в нашем распоряжении синтаксис и базовая семантика, циклы и операторы ветвления, логика и арифметика, таблицы и возможность определять свои функции.

Чего с головой хватит для описания большей части данных, которые нам могут понадобиться: юниты, инвентарь, диалоги, карты, описание уровней, UI, графика, звуки и чего только не.

```lua
-- Lua
-- config_screen.lua

local screen = {
    width = 1280,
    height = 720,
    presets = {
        ["HD"]  = {1280, 720},
        ["FHD"] = {1920, 1080},
        ["4K"]  = {3840, 2160},
        default = "HD"
    }
}
function getScreenPreset(preset)
    local presets = screen.presets
    return presets[preset] or presets[presets.default]
end

return screen
```
```cpp
// Cpp
auto screenCfg = lua.script_file("config_screen.lua");

// доступ к элементам Lua-таблицы по ключу
int width = screenCfg["width"];
int height = screenCfg["height"];

std::cout << std::format("Configured screen resolution: {}x{}\n", width, height);
// --> Configured screen resolution: 1280x720

// можем вызывать функции объявленные в Lua
auto preset = lua["getScreenPreset"]("FHD");

// Доступ по индексу
width = preset[1]; // И да, индексация в Lua начинается c 1
height = preset[2];

std::cout << std::format("FHD resolution: {}x{}\n", width, height);
// --> FHD resolution: 1920x1080
```
А реализовав недостающий функционал на стороне C++, и пробросив его в Lua, можно уже замахиваться на игровую логику.
```cpp
// Cpp
namespace math
{
    int add(int a, int b) { return a + b; };
}

auto api = lua.create_table();

api["add"] = math::add;
api["sub"] = [](int a, int b) { return a - b; };

lua["engineAPI"] = api;

lua.script_file("script.lua");

int a = lua["a"];
std::cout << std::format("a:{}, b:{}\n", a, lua["b"].as<int>());
// --> a:30, b:-10
```
```lua
-- Lua
-- script.lua

a = engineAPI.add(10, 20)
b = engineAPI.sub(10, 20)
```
И на этом можно было бы уже заканчивать.

Но.

У нас уже немало доступного функционала, а вот возможностей чувствительно нашкодить в скриптах ещё не очень _(Кстати, какие варианты приходят в голову? В комментах писать не надо — а то подглянут ещё)_. Я бы всё-таки расширил пространство для манёвра любителям, скажем так, нестандартных решений — ну так, чисто ради подогрева интереса. Это, во-первых... А если серьёзно, у нас напрочь отсутствует возможность вызывать сторонние скрипты из самих скриптов, а это сразу — здравствуй потеря модульности и архитектурной гибкости _(и это для игрового-то движка)_, грабли с условной динамической загрузкой, повышенная нагрузка на API движка _(ну ладно, ладно — читать как "на разработчиков этого самого API")_.

Во-вторых, у нас, в самом начале, в исходных данных была обозначена природная лень. Следовательно, рожать велосипед самостоятельно повторяя функционал стандартных библиотек — ну серьёзно?

Ну а в-третьих, это было бы слишком просто, и даже начинать данную заметку не имело бы смысла. Но если посмотреть на ползунок прокрутки справа, то текста там ещё порядком. Поэтому придётся продолжать.


## Тишина должна быть в библиотеке (c)

Здесь придётся чуть подробнее остановиться на том, что, собственно, представляет из себя загрузка библиотек в Lua.

<details>
<summary> Но начнем мы, как ни странно, с таблиц. [развернуть]</summary>

*Можно смело пропустить, если в курсе внутренней кухни Lua.

В Lua таблицы — это единый и универсальный механизм данных и структурирования, на котором фактически строится вообще весь язык. Они могут хранить значения любого типа: числа, строки, другие таблицы и **функции**. И не просто могут — вообще все переменные, функции, библиотеки и модули являются именно элементами таблиц.

Тип у Lua таблиц является ссылочным, т.е. когда мы присваиваем переменной или передаём в функцию какую-нибудь таблицу, копирования не происходит — присваивается и передаётся только ссылка. Если такая переменная выходит из области видимости или ей присваивается `nil` — ссылка обнуляется. А когда ссылок на нашу таблицу вообще не остаётся, она с чистой совестью выпиливается сборщиком мусора. Очевидно, что у нас должна быть какая-то главная таблица, не удаляемая сборщиком и в которой мы сможем создавать ссылки на новые. 

И вот тут создатели языка подошли с фантазией. Они сделали её неявной, т.е. она есть, и вы можете даже обратиться к ней по имени, но это совсем не обязательно. Вы можете спокойно писать на Lua, даже не подозревая о её существовании. Конечно, есть несколько сценариев, когда явное обращение таки потребуется, но это уже для тех, кто действительно знает, что делает.

Ещё раз: основная точка входа в Lua — скрыта от пользователя, даёт работать с языком, даже не зная о месте её нахождения, а явное обращение к ней в умелых руках позволяет делать нетривиальные вещи.

Есть идеи для названия?
</details>

---

Её величество **`_G`**. Это переменная, содержащая ссылку на предопределённую таблицу глобального окружения. И абсолютно все глобальные переменные и функции являются полями этой таблицы.
```lua
-- Lua
x = 42
print(x)       --> 42
print(_G.x)    --> 42
_G.print(_G.x) --> 42
```

И именно в `_G` загружаются библиотеки, которые представляют из себя не что иное, как просто таблицы с функциями _(упростил, да)_. Создаётся глобальная переменная, и в неё кладётся ссылка на соответствующую таблицу. Всё.

```cpp
// Cpp
sol::state lua;

// Собственно, загрузка библиотек
lua.open_libraries(sol::lib::base, sol::lib::math);

lua.script(R"(
    print("#1 " .. math.max(10, 42, -1))
    print("#2 " .. _G.math.max(10, 42, -1))
)");
// --> #1 42
// --> #2 42
```
За редким исключением, правда — например, функции из `base` кладутся прямо в `_G` — "корень" глобальной области видимости *(тот же `print`, а не `base.print` из примера выше)*, или функция `require`, которую `package` тоже закидывает прямо в `_G`, в отличие от всех остальных своих функций.

Дальше, в Lua нет механизма частичной загрузки библиотек. Первое, что приходит на ум:
```cpp
// Cpp
lua.open_libraries(sol::lib::os);

// просто обнулить опасные функции
os["execute"] = sol::nil
os["remove"] = sol::nil
...
```

Но есть более гибкий вариант — механизм подмены таблицы глобального окружения, который позволяет запускать код в окружении, изолированном от основного Lua-стейта, т.е. в песочнице. В `sol2` это реализуется через `sol::environment`.

```cpp
//Cpp
lua::state lua;
lua::environment sandox(lua, sol::create);
sandbox["_G"] = sandbox;

lua.script_file("script.lua", sandbox);
```
И вот в неё-то мы уже можем спокойно пробросить только те части библиотек, которые посчитаем нужными.

```cpp
//Cpp
lua::state lua;
lua::environment sandox(lua, sol::create);
sandbox["_G"] = sandbox;

const auto checkWhere = R"(
    if print then
        print (whereAmI)
    else
        houston()
    end
)";

auto houston = []() {
    std::cout << "Houston, we have a problem.\n";
};

lua["whereAmI"] = "In a Lua state";
lua["houston"] = houston;

sandbox["whereAmI"] = "In a sandbox";
sandbox["houston"] = houston;

lua.script(checkWhere); // --> Houston, we have a problem.

// Теперь загружаем библиотеку
lua.open_libraries(sol::lib::base);

lua.script(checkWhere); // --> In a Lua state

// *Явно указываем окружение, в котором нужно выполнить
lua.script(checkWhere, sandbox);  // --> Houston, we have a problem.

sandbox["print"] = lua["print"];
lua.script(checkWhere, sandbox); // --> In a sandbox
```
Кстати, тут есть один нюанс. Дело в том, что вот эта запись в Lua:
```cpp
sandbox["libname"] = lua["libname"];
```
это — не копирование, а ссылка на объект. Поэтому, даже если мы хотим разрешить в песочнице библиотеку целиком, то всё равно придётся переносить её содержимое поэлементно, а не через проброс всей библиотечной таблицы.

- Во-первых, библиотека может содержать какие-либо неявные, потенциально небезопасные поля, а Lua позволяет обойти их все простым перебором, даже не зная имён. Да, `_G` это, кстати, тоже касается.
- Во-вторых, это как раз одна из тех самых возможностей нашкодить: доступ к корневой таблице библиотеки позволяет подменять её функции. В случае же поэлементного проброса подмена, конечно, тоже возможна, но это затронет только песочницу — испортится только ссылка на элемент, оставив саму библиотеку невредимой. 

Использование `sol::environment` открывает нам ещё несколько возможностей: например, на одном Lua-стейте делать сразу несколько независимых песочниц — хоть по отдельной на каждый запускаемый скрипт. Что существенно облегчает задачу по реализации обмена данными между песочницами. Или при сбросе песочницы _(например, перезапуск миссии)_ не нужно подгружать все библиотеки заново — мы просто заменяем таблицу-окружение на новую и копируем в неё разрешённые элементы. Ну и наконец, в случае необходимости, для доверенных скриптов в нашем распоряжении оказывается ещё и полнофункциональная версия Lua _(сам Lua-стейт)_. Последнее использовать с оговорками и осторожностью, но тем не менее, возможность такая есть.


Теперь, собственно, библиотеки. Кратко пробежимся по тому, что же они нам предлагают — а то, может, действительно не стоит заморачиваться?

| Библиотека | Назначение | Функционал / Описание |
|-------------|-------------|------------------------|
| **base** | Базовые возможности языка | Основные конструкции Lua: работа с типами, проверка и преобразование значений, обработка ошибок, итерация по таблицам, **выполнение кода из строк или файлов** и базовые средства метапрограммирования. |
| **package** | Система модулей | **Организация и загрузка Lua- и C-модулей, подключение библиотек.** |
| **string** | Работа со строками | Изменение, поиск и шаблонное сопоставление строк, конкатенация, форматирование, преобразование регистра. |
| **table** | Манипуляции с таблицами | Работа с таблицами: сортировка, объединение, вставка, удаление, копирование, преобразование таблиц в строки и обратно. |
| **math** | Математика и случайность | Арифметические, тригонометрические и логарифмические функции, округление, генерация случайных чисел, операции с целыми. |
| **io** | Ввод-вывод | Работа с файлами и стандартными потоками: **открытие, чтение, запись, построчная обработка**, управление буферами. |
| **os** | Доступ к функциям ОС | Работа со временем, датой, **окружением, файлами и системными командами. Позволяет взаимодействовать с внешней средой.** |
| **coroutine** | Кооперативная многозадачность | Создание и управление корутинами: приостановка и возобновление выполнения, реализация последовательных сценариев. |
| **debug** | Отладка | **Доступ к стеку вызовов, локальным переменным и функциям. Используется для профайлинга и инструментов разработки.** |

Из полезных есть ещё **utf8** и **bit32**. Первая, как ни странно, для работы с кодировкой UTF8, и появилась она начиная с версии 5.3. Вторая — реализация битовых операций, но она была только в ветке 5.2, в 5.3 битовые операции уже напрямую в язык завели и надобность в данной библиотеке отпала. И да, битовых операций в 5.1 не было. Совсем.

Даже беглого просмотра достаточно, чтобы понять — брать надо. Но с осторожностью: в таблице в описании **жирным** выделен небезопасный функционал. Вырисовывается вполне себе чёткая картина — для части библиотек содержимое придётся загружать выборочно, а для некоторых — даже их название вслух произносить небезопасно. Поэтому последние просто игнорируем, но если уж совсем приспичит — их функционал придётся реализовывать самостоятельно на стороне движка _(тот же доступ к файловой системе, можно ограничить только на чтение, и только в пределах разрешённых путей)_.

Если же копнуть глубже, то в итоге у нас вырисовывается следующая картина:

**Base** — мастхэв, но:
- Функционал загрузки и запуска кода на выполнение (все эти `load`, `loadstring`, `loadfile`, `dofile`) придётся взять на себя и реализовать безопасные замены самостоятельно. Этим займёмся позже.
- Кроме того, запрещаем всё, что даёт доступ к метатаблицам (`setmetatable`, `getmetatable`) и позволяет их обходить (`rawequal`, `rawget`, `rawset`). Да, метатаблицы сами по себе могут использоваться как мощный инструмент реализации ограничений для небезопасных функций, но, к сожалению, в Lua нет механизма их защиты.
- Не даём пользователю вручную вызвать сборщик мусора через `collectgarbage`.
- Блокируем возможность читать и менять окружение (`getenv`, `setfenv`).
- И напоследок, `print` — заменим на свой вариант, чтобы можно было перенаправить вывод в поток, отличный от `stdout`.

**package** — небезопасна полностью. Единственное, стоит отдельно упомянуть `require`, которая является сильно продвинутой версией `dofile` из `base`, с поиском запрошенного файла в разрешённых путях и контролем повторной загрузки. Есть смысл тоже заменить на нашу безопасную реализацию `dofile`, добавив к ней возможность запроса на загрузку стандартных библиотек из самих скриптов.

**string** — однозначно забираем, за исключением потенциально небезопасной `dump`, которая позволяет получить байткод любой доступной функций.

**table** — целиком безопасна.

**math** — случайную генерацию (`random`, `randomseed`) лучше оставить на стороне хоста _(для мультиплеера она обычно должна быть синхронизирована для всех клиентов)_, а остальное лишним точно не будет.

**io** — действительно, почему бы не дать сомнительным скриптам доступ к файловой системе?

**os** — оставляем только функции для доступа ко времени: `clock`, `difftime` и `time`.

**coroutine** — почему бы и да! Пусть будет.

**debug** — вообще без вариантов, здесь я бы её даже палкой трогать не стал.

**utf8** и **bit32** тоже безопасны целиком, и можно добавлять, но с оглядкой на используемую версию Lua, т.к. они не во всех представлены.

## Поехали... (c)

Так, на данном этапе, похоже, что у нас уже набралась критическая масса информации, достаточная, чтобы начинать реализацию. Но, чтобы нас не разорвало в творческом порыве, пожалуй, стоит сразу обозначить основные моменты, которых будем придерживаться.


1. Песочницы реализуем через механизм подмены глобальной таблицы-окружения (`sol::environment`).
2. На одном Lua-стейте может быть несколько песочниц одновременно.
3. Если уж параноить, то до конца — песочницы могут обладать разным уровнем доверия, поэтому необходимо иметь возможность ограничения списка доступных для них библиотек. Возможность запроса библиотек из самих скриптов, вообще только самым доверенным песочницам дадим, для остальных же — загрузка по разрешённым спискам только в момент создания самой песочницы.
4. Нужен механизм сброса песочниц после использования до их изначального состояния.
5. Библиотеки грузятся в Lua-стейт целиком, а в песочницы из них пробрасываются только безопасные функции. Функции же, которые нельзя, но очень хочется использовать — заменяем своими безопасными реализациями.
7. Должна быть возможность запуска файлов со скриптами из самих скриптов. Здесь ещё придётся учитывать ограничения по доступным путям.


В первую очередь, чтобы можно было вести учёт уже загруженных библиотек и не дёргать `open_libraries()` каждый раз при создании новой песочницы, сделаем обёртку для `sol::state`.
```cpp
class LuaRuntime : public sol::state
{
public:
    sol::state state;

	LuaRuntime() = default;
	~LuaRuntime() = default;

    // Запрещаем копирование и перенос
	LuaRuntime(const LuaRuntime &) = delete;
	LuaRuntime(LuaRuntime &&) = delete;
	LuaRuntime &operator=(const LuaRuntime &) = delete;
	LuaRuntime &operator=(LuaRuntime &&) = delete;

    // Через это будем сообщать какие библиотеки нам понадобятся в песочнице,
    // и что их было бы неплохо загрузить в Lua-стейт
    void require(sol::lib lib)
    {
        if (!loadedLibs.contains(lib)) {
            state.open_libraries(lib);
            loadedLibs.insert(lib);		
        }
    }

private:
    std::set<sol::lib> loadedLibs; // Список уже загруженных библиотек.
};
```

Ну и сама песочница:
```cpp
class LuaSandbox
{
public:
    explicit LuaSandbox(LuaRuntime &runtime)
        : runtime(&runtime)
    {
        reset();
    }
    ~LuaSandbox() = default;

    // Аналогично — явно запрещаем копирование
	LuaSandbox(const LuaSandbox &) = delete;
	LuaSandbox &operator=(const LuaSandbox &) = delete;
    
    // Но перенос оставим, чтобы наши песочницы можно было в контейнерах хранить
	LuaSandbox(LuaSandbox &&) = default;
	LuaSandbox &operator=(LuaSandbox &&) = default;    

    // Перегружаем [], чтобы снаружи был прозрачный доступ к элементам песочницы
    auto operator[](auto &&key) noexcept
    { 
        return sandbox[std::forward<decltype(key)>(key)];
    }

    // Сброс через инициализацию новой песочницы
    // Старую сборщик мусора потом сам грохнет, ну или сразу, если явно попросим
    void reset(bool doCollectGarbage = false)
    {
        sandbox = sol::environment(runtime->state, sol::create);
        sandbox["_G"] = sandbox;

        if (doCollectGarbage) {
            runtime->state.collect_garbage();
        }
    }
    // Запуск скрипта на выполнение в песочнице
    auto run(std::string_view script)
        -> sol::protected_function_result
    {
        // Используем именно safe-версию, чтобы sol2 не выбрасывал нам исключения
        return runtime->state.safe_script(script, sandbox);
    }
    // И файла со скриптом, соответственно. Пока без контроля путей
    auto runFile(const std::filesystem::path &scriptFile)
        -> sol::protected_function_result
    {
        return runtime->state.safe_script_file(scriptFile, sandbox);
    }

private:
    LuaRuntime *runtime {nullptr};
    sol::environment sandbox;
};
```
Обратите внимание: вызов скриптов на выполнение в `run`/`runFile` осуществляется через `safe`-версии `script` и `script_file`. Это сделано специально, чтобы `sol2` нам не выбрасывал исключения в случае ошибки. Эти версии на выходе генерируют объект `sol::protected_function_result`, который сохраняет информацию об ошибках, что позволяет обрабатывать их вручную. Про него ниже поговорим ещё.

И вот теперь, наконец-то, можно переходить к библиотекам.

Мы уже выяснили, что содержимое библиотек грузить придётся выборочно. Насколько выборочно — тоже уже определили. Остаётся только задать соответствующие правила для каждой из библиотек.
```cpp
class LuaSandbox
{
    ...
private:
    using LibNames = std::vector<std::string_view>;

    struct LibSymbolsRules
    {
        LibNames allowed{};                     // Белый список
        LibNames restricted{};                  // Чёрный
        bool allowedAllExceptRestricted{false}; // Определяет какой из списков используется
    };
    using LibsSandboxingRulesMap = std::map<sol::lib, LibSymbolsRules>;

	static const LibsSandboxingRulesMap libsSandboxingRules;
    ...
};

const LuaSandbox::LibsSandboxingRulesMap
LuaSandbox::libsSandboxingRules{
    {sol::lib::base,
        {.allowed = {"assert", "error", "ipairs", "next", "pairs",
                     "pcall", "select", "tonumber", "tostring",
                     "type", "unpack", "_VERSION", "xpcall"}}},
    {sol::lib::coroutine,
        {.allowedAllExceptRestricted = true}},
    {sol::lib::math,
        {.allowedAllExceptRestricted = true,
         .restricted = {"random", "randomseed"}}},
    {sol::lib::os, 
        {.allowed = {"clock", "difftime", "time"}}},
    {sol::lib::string,
        {.allowedAllExceptRestricted = true,
         .restricted = {"dump"}}},
    {sol::lib::table,
        {.allowedAllExceptRestricted = true}}
};
```

<details>
<summary> Так, здесь будет вынужденное отступление от основной темы. А именно, по поводу применения в геймдеве контейнеров, активно использующих динамическую аллокацию памяти. [развернуть]</summary>

Ведь все эти `std::vector`, `std::map` и `std::set` чуть выше по тексту — это как раз они. А для последних двух ещё и локальность данных напрочь отсутствует — там под каждый элемент память выделяется отдельно и, следовательно, располагаться в адресном пространстве они могут где только не.

Да, конкретно в данной ситуации, можно абсолютно пренебречь оказываемым ими влиянием на производительность или фрагментацию памяти. Оно ничтожно, просто в силу их размера и того, что используются, по большей части, только в момент инициализации. Но для чистоты: `set` так и просится заменить его на какой-нибудь `bit_set`, а `map` и `vector`, в которых у нас сейчас сидят правила и список имён таблиц, недоумевают — почему они здесь отдуваются за что-нибудь `constexpr`-производное от того же `std::array`, например?

Просто, с точки зрения наглядности и читабельности, так лучше, а оптимизацию оставим на потом, когда она реально понадобится. ... Кто сказал Технический долг? Не понимаю, о чём вы.
</details>

---

На этом с правилами закончили. Теперь, в соответствии с ними, нужно загрузить сами библиотеки.

Так как мы оперируем библиотеками как `sol::lib`, то нам понадобится хелпер для получения реального Lua-имени:
```cpp
// Заведём отдельный неймспейс для всякого рода вспомогательных функций.
namespace lua   
{
    namespace details
    {
		struct LibName
		{
			sol::lib lib;
			std::string_view name;
		};
		constexpr auto libsNames = std::to_array({
			{sol::lib::base,      "base"},
			{sol::lib::bit32,     "bit32"},     // Lua 5.2 only
			{sol::lib::coroutine, "coroutine"},
			{sol::lib::debug,     "debug"},
			{sol::lib::ffi,       "ffi"},       // LuaJIT only
			{sol::lib::io,        "io"},
			{sol::lib::jit,       "jit"},       // LuaJIT only
			{sol::lib::math,      "math"},
			{sol::lib::os,        "os"},
			{sol::lib::package,   "package"},
			{sol::lib::string,    "string"},
			{sol::lib::table,     "table"},
			{sol::lib::utf8,      "utf8"}       // Lua 5.3+
		});
    } // namespace details

    // Собственно сам хелпер.
	constexpr auto libName(sol::lib lib) noexcept -> std::optional<std::string_view>
	{
		auto findLib = [lib](auto &lookup) -> bool { return lookup.lib == lib; };
		
		const auto &libs = lua::details::libsNames;
		if (auto it = ranges::find_if(libs, findLib); it != libs.end()) {
			return it->name;
		}
		return std::nullopt;
	}

    // Ну и чтобы два раза не вставать, сразу добавим обратный.
	constexpr auto libByName(std::string_view libName) noexcept -> std::optional<sol::lib>
	{
		auto findLibName = [libName](auto &lookup) -> bool { return lookup.name == libName; };

		const auto &libs = lua::details::libsNames;
		if (auto it = ranges::find_if(libs, findLibName); it != libs.end()) {
			return it->lib;
		}
		return std::nullopt;
	}
} // namespace lua
```
Ну и наконец, сам загрузчик:
```cpp
class LuaSandbox
{
    ...
private:
    void copyLibFromState(sol::lib lib, const LibSymbolsRules &rules);
    ...
};

void LuaSandbox::copyLibFromState(sol::lib lib, const LibSymbolsRules &rules)
{
	// Определяемся с именем таблицы, где обитает запрошенная библиотека.
    const auto libLookupName = lua::libLookupName(lib);
	if (libLookupName.empty()) {
		return;
	}
    // Копировать будем отсюда,
	const sol::table src = runtime->state[libLookupName]; 

    // проверив, на всякий случай, что таблица таки существует.
    if (!src.valid()) {
		return;
	}

    // Функции из 'base' заливаются прямо в '_G', который у нас уже есть,
    // для остальных же библиотек придётся создать свои таблицы для копирования.
	if (lib != sol::lib::base) {
		sandbox[libLookupName] = sol::table(runtime->state, sol::create);
	}
    // Сюда.
	sol::table dst = sandbox[libLookupName];

    // Ну и, собственно, то, к чему мы так долго и тернисто шли — заливаем в песочницу,
    if (rules.allowedAllExceptRestricted) {
        // копируя вообще всё содержимое поэлементно,
		for (const auto &[name, object] : src) {
			dst[name] = object;
		}
        // и удаляя запрещёнку.
		for (const auto &name : rules.restricted) {
			dst[name] = sol::nil;
		}
	} else { // Ну или, в случае белого списка,
        // просто грузим только разрешённое.
		for (const auto &name : rules.allowed) {
			dst[name] = src[name];
		}
	}
}

// И чуть не забытый хелпер
namespace lua
{
    // для определения имени таблицы — местоположения библиотеки внутри Lua-стейта.
	constexpr auto libLookupName(sol::lib lib) -> std::string_view
	{
		// Функции из `base` сидят прямо в "корне" — '_G', в отличие от остальных библиотек.
        return (lib == sol::lib::base) ? "_G" : lua::libName(lib).value_or("");
	}
}  // namespace lua
```
И завершаем картину с библиотеками последними штрихами — интерфейс для их загрузки:
```cpp
// С++ — очень элегантный и лаконичный язык, вы только посмотрите как изящно и непринуждённо
// он позволяет выразить синоним для "Какой-нибудь итерируемый контейнер с sol::lib внутри"
template <typename T>
concept SolLibContainer =
	std::ranges::range<T> 
	&& std::same_as<std::ranges::range_value_t<T>, sol::lib>;

// Благодаря чему, мы сможем почти из любого контейнера грузить библиотеки сразу пачкой.
void LuaSandbox::loadLibs(const SolLibContainer auto &libs)
{
    for (const auto &lib : libs) {
        loadLib(lib);
    }
}

// Ну или по одной.
bool LuaSandbox::loadLib(sol::lib lib)
{
    const auto rules = checkRulesFor(lib); // Для неё правила есть вообще?
    if (!rules) {
        return false;
    }
    // Запрос на загрузку библиотеки в Lua-стейт.
    // Нам же нужно её откуда-то в песочницу подтягивать
    runtime->require(lib);

    copyLibFromState(lib, *rules);
    loadedLibs.insert(lib); // Учёт загруженных библиотек

    return true;
}

// Просто проверка на наличие правил для конкретной библиотеки
auto LuaSandbox::checkRulesFor(sol::lib lib) const noexcept
    -> opt_cref<LibSymbolsRules>
{
    if (const auto it = libsSandboxingRules.find(lib); it =! libsSandboxingRules.end()) {
        return it->second;
    }
    return std::nullopt;
}

class LuaSandbox
{
    ...
public:
    void loadLibs(const SolLibContainer auto &libs);
    bool loadLib(sol::lib lib);

private:
    auto LuaSandbox::checkRulesFor(sol::lib lib) const noexcept
        -> opt_cref<LibSymbolsRules>

    std::set<sol::lib> loadedLibs;
    ...
};
```
Здесь может несколько смутить возвращаемый тип `opt_cref<LibSymbolsRules>` для `checkRulesFor`, но это просто константный `std::optional` для `&`ссылок, который в C++ не завезли.

<details>
<summary> Реализация, если интересно. [развернуть]</summary>

```cpp
template <typename T>
class optional_ref
{
public:
    optional_ref() = default;
    optional_ref(std::nullopt_t) : ref(std::nullopt) {}
    optional_ref(T &value) : ref(value) {}

    explicit operator bool() const noexcept { return has_value(); }

    T &operator*() noexcept { return ref->get(); }
    const T &operator*() const noexcept { return ref->get(); }

    T *operator->() noexcept { return std::addressof(**this); }
    const T *operator->() const noexcept { return std::addressof(**this); }

    bool operator==(std::nullopt_t) const noexcept { return !has_value(); }
    bool operator!=(std::nullopt_t) const noexcept { return has_value(); }

    bool has_value() const noexcept { return ref.has_value(); }

    void reset() noexcept { ref.reset(); }

private:
    std::optional<std::reference_wrapper<T>> ref;
};

template <typename T>
using opt_ref = optional_ref<T>;

template <typename T>
using opt_cref = optional_ref<const T>;
```

</details>

---

## Все животные равны, но некоторые равнее.

Вспоминаем про нашу паранойю и позволим создавать песочницы только по заранее заданным шаблонам, ограничивающим список загружаемых библиотек. 

Отдельно выделим шаблон `Custom`, для которого, мало того, что весь список библиотек доступен, так ещё и позволяем загружать их по мере необходимости, а не в момент создания песочницы.

```cpp
class LuaSandbox
{
public:
    enum class Presets { Core, Minimal, Complete, Custom };

    // Чуть доработаем наш конструктор
    // Чтобы без указания шаблона нельзя было создать песочницу
    explicit LuaSandbox(LuaRuntime &state,
                        Presets preset)
        : lua(state),
          preset(preset)
    {...}

    // Ad-hoc загрузка библиотек для его величества Presets::Custom
    bool LuaSandbox::require(sol::lib lib)
    {
        if (preset == Presets::Custom) {
            return loadLib(lib);
        }
        return false;
    }
    ...

private:
    ...
    Presets preset{Presets::Core};

    using SandboxPresets = std::map<Presets, Libs>;
    inline static const SandboxPresets sandboxPresets{
        {Presets::Core, {}},
        {Presets::Minimal,
            {sol::lib::base,
             sol::lib::table}},
        {Presets::Complete,
            {sol::lib::base,
             sol::lib::coroutine,
             sol::lib::math,
             sol::lib::os,
             sol::lib::string,
             sol::lib::table}},
        {Presets::Custom, {}}
    };
};

// Добавим в reset() загрузку библиотек после сброса.
// И, т.к. он у нас несколько распух — вынесем в cpp-файл.
void LuaSandbox::reset(bool doCollectGrbg /* = false */)
{
    sandbox = sol::environment(lua->state, sol::create);
    sandbox["_G"] = sandbox;

    if (loadedLibs.empty()) { 
        // Для конструктора используем список из пресета.
        loadLibs(sandboxPresets.at(preset));
    } else {
        // Если же инкарнация уже не первая, то грузим всё, что было в прошлой жизни.
        loadLibs(loadedLibs);
    }
    // Принудительная уборка мусора, в случае необходимости
    if (doCollectGrbg) {
        lua->state.collect_garbage();
    }
}
```

С основным, вроде разобрались. Что у нас там дальше по списку? 

## Разделяй и властвуй

Возможность запуска файлов со скриптами из самих скриптов.

В Lua это осуществляется двумя путями: через `loadfile`/`dofile` или `require`. Первые два живут в библиотеке `base`, последний — в `package`. Напомню, что ни одну из этих функций мы в песочницу не грузим, а родной `require`, так и вовсе со всей библиотекой игнорируем по соображениям безопасности. Но прежде чем делать свою реализацию, кратко пробежимся по ожидаемому от них поведению.

`loadfile` просто загружает указанный файл, компилирует его в байткод и возвращает как функцию, но не запускает на выполнение. `dofile` же, и загружает _(через тот же самый 'loadfile')_, и запускает.

`requre` же — это механизм Lua для загрузки модулей. Причём в качестве модулей могут выступать, помимо, собственно, скриптов `.lua`, файлы с уже скомпилированным Lua-байткодом _(в данном аспекте, кстати, `dofile` от него тоже не отстаёт)_, и библиотеки: начиная от стандартных Lua-библиотек, о которых мы говорили выше, до обычных динамических C-библиотек _(ну, те, которые `.so/.dll/.dylib`)_. И это всё прямо из коробки. А если ещё добавить свои загрузчики, то проглотит вообще любой формат: будь то JSON, архив или бинарный код. _Вот уж где нашим юным натуралистам действительно было бы где разгуляться._

Кроме того, у `require` есть пара ключевых отличий от `dofile`, на которых придётся остановиться чуть подробнее, так как они важны для нашей реализации:

- Для того чтобы загрузить модуль, нам не нужно знать, где именно тот сидит в файловой системе — достаточно просто указать имя модуля, и `require` сам полезет его искать. И даже больше: `require` в принципе не сможет корректно обработать в качестве своего аргумента имя модуля с явным указанием пути к нему. А вот для `dofile` пути нужно указывать явно:

  `dofile("path/to/our/modules/rocket_science.lua")`

  vs

  `require("rocket_science")`

  Ищет он, конечно, не по всей файловой системе, а только в заранее заданных путях, но механизм защиты переменной, содержащей разрешённые пути отсутствует напрочь — это одна из причин, почему мы не используем родной `require` предоставляемый Lua.

  И да, на отсутствие расширения в имени файла во втором варианте внимание же тоже обратили, да? Это не ошибка — это ещё одна особенность, которую нужно учитывать.

- `require` не просто загружает файл, он задействует механизм кеширования уже подтянутых модулей и при повторном запросе просто подсовывает их из кеша. В нашем случае мы пойдём на упрощение и не будем реализовывать этот функционал, т.к. нам нужен хотрелоад _(перезагрузка модулей в случае их изменения на диске)_, и мы допускаем, что модули могут иметь одинаковые имена, но жить в разных директориях — например, у разных модов могут быть свои реализации.

Итого в сухом остатке по `require` имеем:
1. Скрипты грузить может, но нет возможности явно указать путь к файлу — вычёркиваем, `dofile` для этого лучше подходит.
2. Кеширование для нас не актуально — вычёркиваем.
3. А вот загрузку библиотек, пожалуй, оставим. Но ограничим только стандартными Lua-библиотеками — у нас как раз `Presets::Custom` предполагает такую возможность.

Запуск сторонних скриптов же целиком и полностью возложим на `dofile`.

## Path (2000) by Apocaliptica

Теперь нюансы, касающиеся самих путей.

Первое: `dofile` принимает как абсолютные, так и относительные пути. Причём если с абсолютными всё понятно, то с относительными не всё так однозначно — они интерпретируются не относительно текущего файла или директории скрипта, а относительно текущего рабочего каталога **процесса**. Поэтому, если предполагается хоть какая-то иерархическая организация файлов скриптов, то нам придётся для каждого вызываемого скрипта указывать полный путь к нему. 

Следовательно, для песочниц нам нужно задать:
- Корневую директорию, от которой будут интерпретироваться относительные пути.
- Список разрешённых путей, откуда позволено скрипты запускать.

Переходим к водным процедурам — начнём с добавления поддержки путей:

```cpp
namespace fs = std::filesystem;

class LuaSandbox
{
public:
    ...
    
    using Paths = std::vector<fs::path>;

    // Дополняем конструктор:
	explicit LuaSandbox(LuaRuntime &runtime,
						Presets preset,
						const fs::path &root = {},
						const Paths &allowedPaths = {})
		: runtime(&runtime),
		  preset(preset)
	{
		setPathsForScripts(root, allowedPaths);
		reset();
	}

    void allowScriptPath(const fs::path &path); // Добавляет путь к списку разрешённых
    ...
private:

    void setPathsForScripts(const fs::path &root, const Paths &allowed);

    fs::path scriptsRoot{}; // Содержит абсолютный, лексически нормализованный базовый путь.
                            // Именно отсюда рассчитываются относительные пути скриптов 
							// Если же не задан, то вообще запрещаем запуск файлов

    Paths allowedScriptPaths{}; // Допускаем как относительные, так и абсолютные пути
    ...
}

void LuaSandbox::allowScriptPath(const fs::path &path)
{
	if (scriptsRoot.empty() || path.empty()) {
		return;
	}
    const auto allow = path.is_relative() ? scriptsRoot / path : path;
	allowedScriptPaths.push_back(fs_utils::normalize(allow));
}

void LuaSandbox::setPathsForScripts(const fs::path &root, const Paths &allowed)
{
	if (root.empty() || root.is_relative()) {
		scriptsRoot.clear();
		allowedScriptPaths.clear();
		return;
	}
	scriptsRoot = fs_utils::normalize(root);

	allowedScriptPaths.clear();
	for (const auto &path : allowed) {
		allowScriptPath(path);
	}
}
```
`fs_utils::normalize` в представленном коде — это ещё один хелпер, на сей раз уже для работы с путями. Точнее, `fs_utils` — это неймспейс с несколькими такими утилитами. В силу того, что они лишь косвенно связаны с обсуждаемой темой, подробно останавливаться на этом не будем.

<details>
<summary> Но если вдруг интересно — код fs_utils для самостоятельного ознакомления. [развернуть]</summary>

```cpp
namespace fs = std::filesystem;

// Опять же — изящно и непринуждённо объявляем синоним для "любой контейнер с путями"
template <typename T>
concept fsPaths = 
	std::ranges::range<T>
	&& std::same_as<std::remove_cvref_t<std::ranges::range_value_t<T>>, fs::path>;

namespace fs_utils
{
	inline auto normalize(const fs::path &path) -> fs::path
	{
		auto result = path.lexically_normal();
		if (result.native().ends_with(fs::path::preferred_separator)) {
			return result.parent_path();
		}
		return result;
	}

    // Проверяет, что path находится внутри root
	inline bool startsWith(const fs::path &path, const fs::path &root)
	{
		if (root.empty()) {
			return false;
		}
		const auto rootNorm = normalize(fs::absolute(root));
		const auto pathNorm = normalize(fs::absolute(path));
		const auto [rootEnd, _] = std::ranges::mismatch(rootNorm, pathNorm);
		return rootEnd == rootNorm.end();
	}

    // Проверяет, что path находится внутри одного из roots
	inline bool startsWith(const fs::path &path, const fsPaths auto &roots)
	{
		if (roots.empty()) {
			return false;
		}
		for (const auto &root : roots) {
			if (startsWith(path, root)) {
				return true;
			}
		}
		return false;
	}
} // namespace fs_utils
```
</details>

---

Теперь у нас есть всё необходимое для реализации проверки путей при попытке запуска скрипта.

## Собираем в кучу

Напомню, как сейчас, выглядит уже имеющийся `runFile`, который запускает запрошенный файл со скриптом:

```cpp
auto LuaSandbox::runFile(const fs::path &scriptFile)
    -> sol::protected_function_result
{
    return runtime->state.safe_script_file(scriptFile, sandbox);
}
```
Всё, что нам нужно — это добавить в начало несколько проверок:
- На наличие файла.
- На допустимость его пути.
- И на его содержимое. Точнее, на то, что он **не** содержит уже скомпилированный байткод, т.к. он позволяет обойти ограничения песочницы.

Ну и возврат соответствующей ошибки, если проверка не пройдена. Благо возвращаемый тип `sol::protected_function_result` нам это позволяет, хоть не очень интуитивно.

В итоге у нас получится следующая картина:
```cpp
auto LuaSandbox::runFile(const fs::path &scriptFile)
    -> sol::protected_function_result
{
    // Вручную формируем "ошибочный" результат, содержащий текст сообщение об ошибке
    // Поясниения будут ниже
	auto error = [this, &scriptFile](std::string_view msg) {
		const auto errMsg = std::format("{}: {}", msg, scriptFile.string());
		return lua::makeFnCallResult(runtime->state, errMsg, sol::call_status::file);
	};

	if (!fs::exists(scriptFile)) {
		return error("Attempting to run a non-existent script");
	}
	if (!isPathAllowed(scriptFile)) {
		return error("Attempting to run a script outside the allowed path");
	}
	if (lua::isBytecode(scriptFile)) {
		return error("Attempting to run precompiled Lua bytecode");
	}
	return runtime->state.safe_script_file(scriptFile, sandbox);
}
```
С `fs::exists` всё понятно — функция стандартная, проверяет существование файла или самой директории.

С проверкой допустимости пути тоже всё довольно тривиально:
```cpp
class LuaSandbox
{
    ...
private:
    bool isPathAllowed(const fs::path &scriptFile) const
    {
        // Просто проверяем, что запрашиваемый путь находится внутри одного из списка допустимых
        return fs_utils::startsWith(scriptFile, allowedScriptPaths);
    }
    ...
};
```

А вот с проверкой на байт-код и формированием ошибочного результата выполнения всё не так прозаично.

Файлы, содержащие скомпилированный байт-код, начинаются со специальной сигнатуры `<esc>Lua` что соответствует `\033Lua`, которая в `lua.h` так и объявлена:

```cpp
#define	LUA_SIGNATURE	"\033Lua"
```
Нам нужно просто проверить первые 4 байта файла на соответствие ей.

```cpp
namespace lua
{
	bool isBytecode(const fs::path &file)
	{
		constexpr auto signature = std::string_view(LUA_SIGNATURE);

		auto ifs = std::ifstream(file, std::ios::binary);
		if (!ifs) {
			return false;
		}
		auto header = std::array<char, signature.size()>{};
		ifs.read(header.data(), header.size());
		if (ifs.gcount() < static_cast<std::streamsize>(header.size())) {
			return false;
		}
		return ranges::equal(header, signature);
	}
```

Для формирования же корректного возвращаемого объекта `sol::protected_function_result`, нам нужно:
 1. В случае успешного выполнения функции поместить в стек — возвращаемый функцией Lua-объект, будь то значение, таблица, функция или `nil`;
 2. Или же, в случае ошибки, вместо результата пушим в стек соответствующее ей сообщение; 
 3. И, наконец, создаём объект `sol::protected_function_result` с указанием статуса результата — валидный, который можно использовать дальше, или же — ошибка, которую нужно обработать. Здесь же указываем количество объектов, которое поместили в стек _(да, их может быть несколько, но в нашем случае используем только один)_, эта информация в т.ч. нужна деструктору `sol::protected_function_result` для того, чтобы подчистить стек за собой, но это уже нюансы реализации `sol2`, не будем углубляться.

```cpp
	auto makeFnCallResult(sol::state &lua,
						  const auto &object,
						  sol::call_status callStatus = sol::call_status::ok)
		-> sol::protected_function_result
	{
		bool isResultValid = callStatus == sol::call_status::ok;
		sol::stack::push(lua, object);
		return sol::protected_function_result(lua, -1, isResultValid ? 1 : 0, 1, callStatus);
	}
} // namespace lua
```

Осталось обернуть `runFile` таким образом, чтобы он мог напрямую принимать аргументы из Lua скриптов — а там это реализуется через универсальный `sol::stack_object`, и, собственно, всё — замена для `dofile` у нас готова:

```cpp
auto LuaSandbox::dofileReplace(sol::stack_object fileName)
    -> sol::protected_function_result
{
	auto nil = [this]() { return lua::makeFnCallResult(runtime->state, sol::nil); };

	if (!fileName.is<std::string>()) {
		return nil();
	}
	const auto filePath = toScriptPath(fileName.as<std::string>());
	if (auto result = runFile(filePath); result.valid()) {
		return result;
	}
	return nil();
}

auto LuaSandbox::toScriptPath(const std::string &fileName) const
    -> fs::path
{
	auto scriptPath = fs::path(fileName);
	if (scriptPath.is_relative()) {
		scriptPath = scriptsRoot / scriptPath;
	}
	return scriptPath.lexically_normal();
}
```

С заменой для `require` всё существенно проще: если запрашиваемый аргумент — имя стандартной Lua-библиотеки, то пробуем её загрузить. Контроль того, что можно загружать и для какого из пресетов `LuaSandbox::Presets`, у нас уже реализован. Так что, в случае успеха, возвращаем таблицу с загруженной библиотекой, иначе `nil`.

```cpp
auto LuaSandbox::requireReplace(sol::stack_object target)
    -> sol::protected_function_result
{
	auto nil = [this]() { return lua::makeFnCallResult(runtime->state, sol::nil); };

	if (!target.is<std::string>()) {
		return nil();
	}
	const auto possibleLibName = target.as<std::string>();
	if (const auto lib = lua::libByName(possibleLibName); lib.has_value()) {
		if (require(*lib)) { // Все проверки на допустимость у нас там уже реализованы
			const auto libLookupName = lua::libLookupName(*lib);
			return lua::makeFnCallResult(runtime->state, sandbox[libLookupName]);
		}
	}
    return nil();
}
```

Ну и, конечно, не забываем добавить их в `LuaSandbox`:

```cpp
class LuaSandbox
{
    ...
private:

	auto dofileReplace(sol::stack_object fileName) -> sol::protected_function_result;
	auto requireReplace(sol::stack_object target) -> sol::protected_function_result;

    void loadSafeExternalScriptFilesRoutine()
    {
        sandbox.set_function("dofile", &LuaSandbox::dofileReplace, this);
        sandbox.set_function("require", &LuaSandbox::requireReplace, this);
    }    

	auto toScriptPath(const std::string &fileName) const -> fs::path;

	bool isPathAllowed(const fs::path &scriptFile) const;
    ...
};
```
И на этом с водными процедурами заканчиваем.

## Hello world!

Дальше `print`. В принципе, его можно было бы и родной оставить, но раз есть возможность перенаправить его выхлоп куда-нибудь помимо `stdout` то почему бы ею не воспользоваться? Просто добавим опцию изменения потока вывода.

```cpp
void LuaSandbox::printReplace(sol::variadic_args args)
{
	std::string result;
	for (auto &&arg : args) {
		result += lua::toString(arg);
        result += " "; // родной print все аргументы разделяет пробелами
	}
	if (!result.empty()) {
		result.pop_back(); // удаляем лишний пробел в конце
	}
	*printOutStrm << "[lua sandbox]:> " << result << "\n";
}
```
Для сохранения логики работы оригинального `print` — а он мало того, что сам корректно конвертирует числа, так ещё и для таблиц и функций, полученных в качестве аргументов, даст строки вида `table: 0x12345` / `function: 0x...` — нам придётся задействовать стандартный `tostring` из `sol::lib::base`. Причём в саму песочницу его грузить не нужно — достаточно того, чтобы он присутствовал в Lua-стейте:

```cpp
namespace lua
{
	auto toString(const sol::object &obj) -> std::string
	{
		sol::state_view lua(obj.lua_state());
		if (!lua["tostring"].valid()) {
			return {};
		}
		return lua["tostring"](obj).get<std::string>();
	}
} // namespace lua
```
Объявляем:
```cpp
class LuaSandbox
{
public:
    ...
	explicit LuaSandbox(LuaRuntime &runtime,
						Presets preset,
						const fs::path &root = {},
						const Paths &allowedPaths = {},
						std::ostream &printOutStrm = std::cout)  // По умолчанию оставляем `stdout`
		: runtime(&runtime),
		  preset(preset),
		  printOutStrm(&printOutStrm)
	{...}

    ...

private:
    void printReplace(sol::variadic_args args);

	void loadSafePrint()
    {
    	// В Lua-стейт должна быть загружена библиотека base, чтобы tostring работал
        runtime->require(sol::lib::base);
	    sandbox.set_function("print", &LuaSandbox::printReplace, this);
    }
    ...

    std::ostream *printOutStrm;
};
```
## Не трогай, это на новый год

Прежде чем переходить к ограничению потребляемой памяти, сначала разберёмся как, собственно, в Lua реализована работа с ней.

Каждый раз, когда Lua требуется выделить, перераспределить или освободить память происходит вызов одного универсального аллокатора, который всё это умеет.

```lua
-- Создаём новую таблицу?
supply = {'Sugar', 'Water'} -- Lua запрашивает новую память через аллокатор

-- Добавляем элемент в уже существующую?
table.insert(supply, 'Yeast') -- Lua через тот же аллокатор изменяет размер

-- Загружаем новые функции?
dofile("booze_routine.lua") -- Снова дёргаеся аллокатор - выделяет под них память.

local shot = getBooze(supply)

shot.coolingTo(6)

-- Удаляем объект?
drink(shot) -- Тоже через аллокатор, но отложенно, а не в момент удаления.
            -- Сборщик мусора его вызовет когда посчитает нужным.
            -- Сам же объект в Lua считается удалённым сразу.
```

```Lua
-- booze_routine.lua
function getBooze(rawMaterials)

    local barrel = getBarrel();

    for i = #rawMaterials,1,-1 do
        local item = table.remove(rawMaterials) 
        barrel.put(item)
    end

    barrel.warmUpTo(23)

    while not barrel.isReady() do
        barrel.proceed()
    end
    return distilate(barrel)
end

function drink(what)
    what = nil
end
```

Если прям совсем упростить, то весь требуемый функционал — выделение, удаление и изменение размера уже выделенного блока — реализуется на коленке через `realloc` и `free`:

```cpp
void *luaAlloc(void *ptr, size_t newSize)
{
    if (newSize == 0) {
        free(ptr);
        return NULL;
    }
    return realloc(ptr, newSize);
}
```
Собственно, стандартный именно так и выглядит. Ну, за исключением пары нюансов, о которых чуть позже.

А теперь самое интересное: Lua позволяет подменить свой стандартный аллокатор пользовательским и гарантирует, что абсолютно все запросы памяти будут идти именно через него. То есть механизм у нас есть: перехватываем контроль за выделением памяти, ведём её учёт и, в случае превышения лимитов, просто не даём лишнего.

Более того, Lua нам существенно упрощает жизнь в плане реализации учёта, т.к. на самом деле в аллокатор передаются ещё два очень полезных для нас параметра:

```cpp
void *luaAlloc(void *ud, void *ptr, size_t currSize, size_t newSize)
```
`ud` — указатель на блок пользовательских данных, и `currSize` — текущий размер блока памяти, на который указывает `*ptr`.

Причём, если с первым всё прозаично — мы можем указать Lua на любую структуру с произвольным набором переменных, которую хотим видеть в качестве аргумента в аллокаторе. То с текущим размером блока чуть сложнее.

Дело в том, что он, как бы это сказать... он — не всегда размер. Если `*ptr` ссылается на уже выделенную память, то это размер. А вот если Lua запрашивает выделение нового блока памяти (`*ptr == NULL`), то он может принимать другие значения: например, код типа объекта который Lua сейчас пытается создать, ну так, чисто в качестве подсказки. Имейте в виду — это поведение завезли только для Lua 5.2+. Можно смело пользоваться, если пишете навороченный аллокатор, оптимизирующий выделение памяти.

Всё, что нам остаётся - обеспечить такое поведение нашего аллокатора, которое удовлетворяет ожиданиям Lua:

| `*ptr` | `currSize` | `newSize` | ожидаемое поведение |
|--------|------------|-----------|---------------------|
| `NULL` | 0 либо код типа | > 0 | Выделяем новый блок запрошенного размера. Возвращаем указатель на него, либо `NULL` если выделить не удалось. |
| `!NULL`| > 0 | 0 | Освобождаем память, на которую ссылается `ptr`. Возвращаем `NULL`. |
| `!NULL`| > 0 | > 0 | Прикидываемся `realloc`'ом: изменяем размер блока, на который указывает `*ptr`, возвращаем указатель в случае успеха или `NULL`, если увеличить не удалось. |

Сама же подмена осуществляется в момент создания Lua-стейта:
```cpp
void *limitedAlloc(void *ud, void *ptr, size_t currSize, size_t newSize);

constexpr size_t cLualMemoryLimit = 1 * 1024 * 1024; // 1 Mb

struct LuaAllocatorState
{
    size_t used {};
    size_t limit {cLualMemoryLimit};
} allocState;

sol::state lua(sol::default_at_panic, limitedAlloc, &allocState);

```
Насчёт первого аргумента - `sol::default_at_panic` - не заморачиваемся, это дефолтный `sol`'овский обработчик ошибок типа "всё пропало". Просто в конструкторе он идёт первым, и мы вынуждены его указать явно, чтобы была возможность задать последние два аргумента.


```cpp
namespace lua
{
    namespace memory
	{
		constexpr size_t c1MB = 1L * 1024 * 1024;
		constexpr size_t cDefaultMemLimit = c1MB;

		struct LimitedAllocatorState
		{
			size_t used {};
			size_t limit {cDefaultMemLimit};
			bool limitReached {false}; // Добавили флаги для фиксации достижения лимита
			bool overflow {false};     // и переполнения
		};

		void *limitedAlloc(void *ud, void *ptr, size_t currSize, size_t newSize) noexcept
		{
			auto *allocState = static_cast<LimitedAllocatorState*>(ud);

			// Отакзываемся работать без указателя на состояние
            if (allocState == nullptr) {
				assert(allocState != nullptr);
				return nullptr;
			}

			if (ptr == nullptr) {
                // Здесь обработка подсказок насчёт типа объекта, который Lua пытается создать.
                // ...
                // И обнуляем currSize для того, чтобы дальше арифметика коректно работала.
				currSize = 0;
			}
			if (newSize == 0) {
				if (ptr != nullptr) {
                    // Просто на всякий случай, чтобы не улететь ниже 0
					allocState->used -= (allocState->used >= currSize) ? currSize
																	   : allocState->used;
				}
				std::free(ptr);
				return nullptr;
			}
            // Опять же, чтобы не свалиться ниже 0 при дальнейших расчётах
			const size_t usedBase = (allocState->used >= currSize) ? allocState->used - currSize
																   : 0;
            // Защита от переполнения
			if (newSize > (std::numeric_limits<size_t>::max() - usedBase)) {
				allocState->overflow = true;
				return nullptr;
			}
			const size_t newUsed = usedBase + newSize;
			if (newUsed > allocState->limit) {
				allocState->limitReached = true;
				return nullptr;
			}
			void *newPtr = std::realloc(ptr, newSize);
			if (newPtr != nullptr) {
				allocState->used = newUsed;
			}
			return newPtr;
		};
	} // namespace memory
} // namespace lua

```
```cpp
class LuaRuntime
{
private:
	lua::memory::LimitedAllocatorState allocatorState;

public:
    // Добавляем ещё один конструктор в LuaRuntime:
    // и теперь можем создавать рантаймы с поддержкой лимитов на память
	LuaRuntime(size_t memoryLimit)
		: allocatorState({.limit = memoryLimit})
		, state(sol::default_at_panic, lua::memory::limitedAlloc, &allocatorState)
	{}
    ...
};
```





Код в удобоваримой форме можно посмотреть [здесь](https://github.com/ipochto/articles/tree/master/Sandboxing%20Lua/src)

---

## Что пока не охвачено данной реализацией.

1. Защита от зависаний на стороне lua-скриптов: решается через хуки и таймауты — если скрипт выполняется дольше чем разрешено таймаутом, то скрипт просто прибивается. Да, это не решает проблему неработоспособности скрипта, но, по крайней мере, даёт возможность нашему движку отработать ошибку и работать дальше, не вылетев из-за кривого мода/карты. 
2. Механизм контроля целостности доверенных скриптов — например, скриптов, поставляемых нами самими. Со скриптами модов пользователь может делать что угодно, но для гарантированной работоспособности движка родные скрипты трогать не стоит.
3. Hotreload — по факту изменения.

