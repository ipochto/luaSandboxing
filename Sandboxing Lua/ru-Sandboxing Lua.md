# Заметки на полях: Изолируем Lua окружение в C++ приложении.
tags: c++, lua, gamedev, sol2

## Постановка задачи
Для начала накинем немного контекста.
- Во-первых, в качестве C++ хоста у нас выступает игровой движок, где скриптовый язык нужен для конфигов, логики, модов и вот этого вот всего.
- Во-вторых, нужна возможность запуска сторонних, написанных не нами (читай непроверенных и потенциально небезопасных) скриптов.
- В-третьих, исходя из вышеобозначенного, очень желательно свести к минимуму возможности нашкодить, со стороны особенно любознательных пользователей, очень творческих мододелов и просто мамкиных кулхацкеров;
- В-четвёртых, берём как данность, что автор этих строк от природы откровенно ленив и, поэтому, по максимуму стараемся использовать уже готовые решения.

Опустим рассуждения о достоинствах и недостатках Lua в качестве скриптового языка, а так же обзор возможных вариантов его подключения к нашему приложению - для этого есть уйма статей, написанных такими корифеями, что я даже смысла не вижу залезать на эту поляну. А, просто, возьмём как данность, что выбор в итоге остановили на:
- Lua 5.1/LuaJIT: Версии после 5.1 показывают деградацию по скорости выполнения _(а у нас же геймдев)_, а JIT-версия, в принципе остановилась в своём развитии на этапе 5.1;
- Для подключения используем `sol2` - невероятно вкусная библиотека, которая просто до неприличия упрощает взаимодействие с Lua. Опять же, без ущерба скорости _(ну геймдев же, ну)_;
- Ну и C++20. Просто потому, что есть такая возможность. Впрочем, всё, описанное ниже, вполне реализуемо и на более взрослых версиях стандарта.


## По пути наименьшего сопротивления

Для выполнения Lua-кода из нашего приложения необходимо создать для него окружение - фактически виртуальную машину, содержащую всё необходимое для запуска скриптов - стек, глобальные переменные, таблицы и функции, а также аллокатор и сборщик мусора. В терминологии Lua это называется **_state_** (состояние).

Создание всего этого - задача, конечно, довольно нетривиальная. 
<details>
<summary> И, в нашем случае, решается через...</summary>

```cpp
// Добавление аж двух строк )
#include <sol/sol.hpp>
sol::state lua;
```
</details>

-----

Собственно, уже на этом этапе в нашем распоряжении - синтаксис и базовая семантика, циклы и операторы ветвления, логика и арифметика, таблицы и возможность определять свои функции.

Чего с головой хватит для описания большей части данных, которые нам могут понадобиться - юниты, инвентарь, диалоги, карты, описание уровней, UI, графика, звуки и чего только не.

```lua
-- Lua
-- config_screen.lua

local screen = {
    width = 1280,
    height = 720,
    presets = {
        ["HD"]  = {1280, 720},
        ["FHD"] = {1920, 1080},
        ["4K"]  = {3840, 2160},
        default = "HD"
    }
}
function getScreenPreset(preset)
    local presets = screen.presets
    return presets[preset] or presets[presets.default]
end

return screen
```
```cpp
// Cpp
auto screenCfg = lua.script_file("config_screen.lua");

// доступ к элементам Lua-таблицы по ключу
int width = screenCfg["width"];
int height = screenCfg["height"];

std::cout << std::format("Configured screen resolution: {}x{}\n", width, height);
// --> Configured screen resolution: 1280x720

// можем вызывать функции объявленные в Lua
auto preset = lua["getScreenPreset"]("FHD");

// Доступ по индексу
width = preset[1]; // И да, индексация в Lua начинается c 1
height = preset[2];

std::cout << std::format("FHD resolution: {}x{}\n", width, height);
// --> FHD resolution: 1920x1080
```
А, реализовав недостающий функционал на стороне C++, и, пробросив его в Lua, можно уже замахиваться на игровую логику.
```cpp
// Cpp
namespace math
{
    int add(int a, int b) { return a + b; };
}

auto api = lua.create_table();

api["add"] = math::add;
api["sub"] = [](int a, int b) { return a - b; };

lua["engineAPI"] = api;

lua.script_file("script.lua");

int a = lua["a"];
std::cout << std::format("a:{}, b:{}\n", a, lua["b"].as<int>());
// --> a:30, b:-10
```
```lua
-- Lua
-- script.lua

a = engineAPI.add(10, 20)
b = engineAPI.sub(10, 20)
```
И на этом можно было бы уже заканчивать.

Но.

У нас уже не мало доступного функционала, а вот возможностей чувствительно нашкодить в скриптах ещё не очень _(Кстати, какие варианты приходят в голову? В комментах писать не надо - а то подглянут ещё)_. Я бы, всё-таки, расширил пространство для манёвра любителям, скажем так, нестандартных решений - ну так, чисто ради подогрева интереса. Это во-первых... А если серьёзно - у нас напрочь отсутствует возможность вызывать сторонние скрипты из самих скриптов, а это сразу - здравствуй потеря модульности и архитектурной гибкости _(и это для игрового-то движка)_, грабли с условной динамической загрузкой, повышенная нагрузка на API движка _(ну ладно, ладно - читать как "на разработчиков этого самого API")_.

Во-вторых, у нас, в самом начале, в исходных данных была обозначена природная лень. Следовательно, рожать велосипед самостоятельно повторяя функционал стандартных библиотек - ну серьёзно?

Ну а в-третьих, это было бы слишком просто, и даже начинать данную заметку не имело бы смысла. Но если посмотреть на ползунок прокрутки справа, то текста там там ещё порядком. Поэтому придётся продолжать. 


## Стандартные Lua библиотеки

Здесь придётся чуть подробнее остановиться на том, что, собственно, представляет из себя загрузка библиотек в Lua.

<details>
<summary> Но начнем мы, как ни странно, с таблиц. </summary>

*Можно смело пропустить, если в курсе внутренней кухни Lua.

В Lua таблицы - это единый и универсальный механизм данных и структурирования, на котором, фактически, строится вообще весь язык. Они могут хранить значения любого типа - числа, строки, другие таблицы и **функции**. И не просто могут - вообще все переменные, функции, библиотеки и модули являются именно элементами таблиц.

Тип у Lua таблиц является ссылочным - т.е. когда мы присваиваем переменной или передаём в функцию какую-нибудь таблицу, копирования не происходит - присваивается и передаётся только ссылка. Если такая переменная выходит из области видимости или ей присваивается `nil` - ссылка обнуляется. А когда ссылок на нашу таблицу вообще не остаётся, она с чистой совестью выпиливается сборщиком мусора. Очевидно, что у нас должна быть какая-то главная таблица, не удаляемая сборщиком и в которой мы сможем создавать ссылки на новые. 

И вот тут, создатели языка подошли с фантазией. Они сделали её неявной - т.е. она есть, и вы можете даже обратиться к ней по имени, но это совсем не обязательно. Вы можете спокойно писать на Lua, даже не подозревая о её существовании. Конечно, есть несколько сценариев, когда явное обращения, таки, потребуется - но это уже для тех, кто действительно знает что делает.

Ещё раз: основная точка входа в Lua - скрыта от пользователя, даёт  работать с языком даже не зная о месте её нахождения, а явное обращение к ней в умелых руках позволяет делать нетривиальные вещи.

Есть идеи для названия?
</details>

---

Её величество **`_G`**. Это переменная, содержащая ссылку на предопределённую таблицу глобального окружения. И абсолютно все глобальные переменные и функции являются полями этой таблицы.
```lua
-- Lua
x = 42
print(x)       --> 42
print(_G.x)    --> 42
_G.print(_G.x) --> 42
```

И именно в `_G` загружаются библиотеки, которые представляют из себя ни что иное, как просто таблицы с функциями _(упростил, да)_. Создаётся глобальная переменная и в неё кладётся ссылка на соответствующую таблицу. Всё.

```cpp
// Cpp
sol::state lua;

// Собственно, загрузка библиотек
lua.open_libraries(sol::lib::base, sol::lib::math);

lua.script(R"(
    print("#1 " .. math.max(10, 42, -1))
    print("#2 " .. _G.math.max(10, 42, -1))
)");
// --> #1 42
// --> #2 42
```
За редким исключением правда - например, функции из `base` кладутся прямо в `_G` - "корень" глобальной области видимости *(тот же `print`, а не `base.print` из примера выше)*, или функция `require`, которую `package` тоже закидывает прямо в `_G`, в отличие от всех остальных своих функций. .

Дальше, в Lua нет механизма частичной загрузки библиотек. Первое, что приходит на ум:
```cpp
// Cpp
lua.open_libraries(sol::lib::os);

// просто обнулить опасные функции
os["execute"] = sol::nil
os["remove"] = sol::nil
...
```

Но есть более гибкий вариант - механизм подмены таблицы глобального окружения, который позволяет запускать код в окружении, изолированном от основного Lua-стейта - т.е. в песочнице. В `sol2` это реализуется через `sol::environment`.

```cpp
//Cpp
lua::state lua;
lua::environment sandox(lua, sol::create);
sandbox["_G"] = sandbox;

lua.script_file("script.lua", sandbox);
```
И вот в неё-то мы уже можем спокойно пробросить только те части библиотек, которые посчитаем нужными.

```cpp
//Cpp
lua::state lua;
lua::environment sandox(lua, sol::create);
sandbox["_G"] = sandbox;

const auto checkWhere = R"(
    if print then
        print (whereAmI)
    else
        houston()
    end
)";

auto houston = []() {
    std::cout << "Houston, we have a problem.\n";
};

lua["whereAmI"] = "In a Lua state";
lua["houston"] = houston;

sandbox["whereAmI"] = "In a sandbox";
sandbox["houston"] = houston;

lua.script(checkWhere); // --> Houston, we have a problem.

// Теперь загружаем библиотеку
lua.open_libraries(sol::lib::base);

lua.script(checkWhere); // --> In a Lua state

// *Явно указываем окружение, в котором нужно выполнить
lua.script(checkWhere, sandbox);  // --> Houston, we have a problem.

sandbox["print"] = lua["print"];
lua.script(checkWhere, sandbox); // --> In a sandbox
```
Кстати, тут есть один нюанс. Дело в том, что в Lua это:
```cpp
sandbox["libname"] = lua["libname"];
```
не копирование, а ссылка на объект. Поэтому даже если мы хотим разрешить в песочнице библиотеку целиком, то всё-равно придётся переносить её содержимое поэлементно, а не через проброс всей библиотечной таблицы.

- Во-первых, библиотека может содержать какие-либо неявные потенциально небезопасные поля, а Lua позволяет обойти их все простым перебором, даже не зная имена. Да, `_G` это, кстати, тоже касается.
- Во-вторых, это как раз одна из тех самых возможностей нашкодить - доступ к корневой таблице библиотеки позволяет подменять её функции. В случае же проброса поэлементно, подмена, конечно, тоже возможна, но это затронет только песочницу, оставив саму библиотеку невредимой. 

Использование `sol::environment` открывает нам ещё несколько возможностей: например, на одном Lua-стейте делать сразу несколько независимых песочниц - хоть по отдельной на каждый запускаемый скрипт. Что существенно облегчает задачу по реализации обмена данными между песочницами. Или при сбросе песочницы _(например перезапуск миссии)_ не нужно подгружать все библиотеки заново - мы просто заменяем таблицу-окружение на новую и копируем в неё разрешённые элементы. Ну и наконец, в случае необходимости, для доверенных скриптов в нашем распоряжении оказывается ещё и полнофункциональная версия Lua _(сам Lua-стейт)_. Последнее  использовать с оговорками и осторожностью, но тем не менее, возможность такая есть.


Теперь, собственно, библиотеки. Кратко пробежимся по тому, что же они нам предлагают - а то, может, действительно не стоит заморачиваться?

| Библиотека | Назначение | Функционал / Описание |
|-------------|-------------|------------------------|
| **base** | Базовые возможности языка | Основные конструкции Lua: работа с типами, проверка и преобразование значений, обработка ошибок, итерация по таблицам, **выполнение кода из строк или файлов** и базовые средства метапрограммирования. |
| **package** | Система модулей | **Организация и загрузка Lua- и C-модулей, подключение библиотек.** |
| **string** | Работа со строками | Изменение, поиск и шаблонное сопоставление строк, конкатенация, форматирование, преобразование регистра. |
| **table** | Манипуляции с таблицами | Работа с таблицами: сортировка, объединение, вставка, удаление, копирование, преобразование таблиц в строки и обратно. |
| **math** | Математика и случайность | Арифметические, тригонометрические и логарифмические функции, округление, генерация случайных чисел, операции с целыми. |
| **io** | Ввод-вывод | Работа с файлами и стандартными потоками: **открытие, чтение, запись, построчная обработка**, управление буферами. |
| **os** | Доступ к функциям ОС | Работа со временем, датой, **окружением, файлами и системными командами. Позволяет взаимодействовать с внешней средой.** |
| **coroutine** | Кооперативная многозадачность | Создание и управление корутинами: приостановка и возобновление выполнения, реализация последовательных сценариев. |
| **debug** | Отладка | **Доступ к стеку вызовов, локальным переменным и функциям. Используется для профайлинга и инструментов разработки.** |


Из полезных есть ещё **utf8** и **bit32**. Первая, как ни странно, для работы с кодировкой UTF8, вторая - реализация битовых операций. Но их завезли уже после Lua 5.1, поэтому игнорируем. Да, битовых операций в 5.1 нет. Совсем.

Даже беглого просмотра достаточно чтобы понять - брать надо. Но с осторожностью - в таблице в описании **жирным** выделен небезопасный функционал. Вырисовывается вполне себе чёткая картина - для части библиотек содержимое придётся загружать выборочно, а для некоторых - даже их название вслух произносить небезопасно. Поэтому последние просто игнорируем, но если уж совсем приспичит - их функционал придётся реализовывать самостоятельно на стороне движка _(тот же доступ к файловой системе, можно ограничить только на чтение, и только в пределах разрешённых путей)_.

Если же копнуть глубже, то в итоге у нас вырисовывается следующая картина:

**Base** - мастхэв, но:
- Функционал загрузки и запуска кода на выполнение (все эти `load`, `loadstring`, `loadfile`, `dofile`) придётся взять на себя и реализовать безопасные замены самостоятельно. Этим займёмся позже.
- Кроме того, запрещаем всё, что даёт доступ к метатаблицам (`setmetatable`, `getmetatable`) и позволяет их обходить (`rawequal`, `rawget`, `rawset`). Да, метатаблицы сами по себе могут использоваться как мощный инструмент реализации ограничений для небезопасных функций, но, к сожалению, в Lua нет механизма их защиты.
- Не даём пользователю вручную вызвать сборщик мусора через `collectgarbage`;
- Блокируем возможность читать и менять окружение (`getenv`, `setfenv`);
- И напоследок, `print` - заменим на свой вариант, чтобы можно было перенаправить вывод в поток отличный от `stdout`.

**package** - небезопасна полностью. Единственное, стоит отдельно упомянуть `require`, которая является сильно продвинутой версией `dofile` из `base`, с поиском, запрошенного файла, в разрешённых путях и контролем повторной загрузки. Есть смысл тоже заменить на нашу безопасную реализацию `dofile`, добавив к ней возможность запроса на загрузку стандартных библиотек из самих скриптов.

**string** - однозначно забираем, за исключением потенциально небезопасной `dump`, которая позволяет получить байткод любой доступной функций.

**table** - целиком безопасна.

**math** - случайную генерацию (`random`, `randomseed`) лучше оставить на стороне хоста _(для мультиплеера она обычно должна быть синхронизирована для всех клиентов)_, а остальное лишним точно не будет.

**io** - действительно, почему бы не дать сомнительным скриптам доступ к файловой системе?

**os** - оставляем только функции для доступа ко времени - `clock`, `difftime` и `time`.

**coroutine** - почему бы и да! Пускай будет.

**debug** - вообще без вариантов, здесь я бы её даже палкой трогать не стал.

## Поехали... (c)

Так, на данном этапе, похоже, что у нас уже набралась критическая масса информации, достаточная, чтобы начинать реализацию. Но, чтобы нас не разорвало в творческом порыве, пожалуй, стоит сразу обозначить основные моменты, которых будем придерживаться.


1. Песочницы реализуем через механизм подмены глобальной таблицы-окружения (`sol::environment`).
2. На одном Lua-стейте может быть несколько песочниц одновременно.
3. Если уж параноить, то до конца - песочницы могут обладать разным уровнем доверия, поэтому необходимо иметь возможность ограничения списка доступных для них библиотек. Возможность запроса библиотек из самих скриптов, вообще только самым доверенным песочницам дадим, для остальных же - загрузка по разрешённым спискам только в момент создания самой песочницы.
4. Нужен механизм сброса песочниц после использования до их изначального состояния.
5. Библиотеки грузятся в Lua-стейт целиком, а в песочницы из них пробрасываются только безопасные функции. Функции же, которые нельзя, но очень хочется использовать - заменяем своими безопасными реализациями.
7. Должна быть возможность запуска файлов со скриптами из самих скриптов. Здесь ещё придётся учитывать ограничения по доступным путям.
8. ...


В первую очередь, чтобы можно было вести учёт уже загруженных библиотек и не дёргать `open_libraries()` каждый раз при создании новой песочницы, сделаем обёртку для `sol::state`.
```cpp
class LuaRuntime : public sol::state
{
public:
    sol::state state;

	LuaRuntime() = default;
	~LuaRuntime() = default;

    // Запрещаем копирование и перенос
	LuaRuntime(const LuaRuntime &) = delete;
	LuaRuntime(LuaRuntime &&) = delete;
	LuaRuntime &operator=(const LuaRuntime &) = delete;
	LuaRuntime &operator=(LuaRuntime &&) = delete;

    // Через это будем сообщать какие библиотеки нам понадобятся в песочнице,
    // и что их было бы неплохо загрузить в Lua-стейт
    void require(sol::lib lib)
    {
        if (!loadedLibs.contains(lib)) {
            state.open_libraries(lib);
            loadedLibs.insert(lib);		
        }
    }

private:
    std::set<sol::lib> loadedLibs; // Список уже загруженных библиотек.
};
```

Ну и сама песочница:
```cpp
class LuaSandbox
{
public:
    explicit LuaSandbox(LuaRuntime &runtime)
        : runtime(&runtime)
    {
        reset();
    }
    ~LuaSandbox() = default;

    // Аналогично - явно запрещаем копирование
	LuaSandbox(const LuaSandbox &) = delete;
	LuaSandbox &operator=(const LuaSandbox &) = delete;
    
    // Но перенос оставим, чтобы наши песочницы можно было в контейнерах хранить
	LuaSandbox(LuaSandbox &&) = default;
	LuaSandbox &operator=(LuaSandbox &&) = default;    

    // Перегружаем [], чтобы снаружи был прозрачный доступ к элементам песочницы
    auto operator[](auto &&key) noexcept
    { 
        return sandbox[std::forward<decltype(key)>(key)];
    }

    // Сброс через инициализацию новой песочницы
    // Старую сборщик мусора потом сам грохнет, ну или сразу, если явно попросим
    void reset(bool doCollectGarbage = false)
    {
        sandbox = sol::environment(runtime->state, sol::create);
        sandbox["_G"] = sandbox;

        if (doCollectGarbage) {
            runtime->state.collect_garbage();
        }
    }
    // Запуск скрипта на выполнение в песочнице
    auto run(std::string_view script) -> sol::protected_function_result
    {
        return runtime->state.safe_script(script, sandbox);
    }
    // И файла со скриптом, соответственно. Пока без контроля путей
    auto runFile(const fs::path &scriptFile) -> sol::protected_function_result
    {
        return runtime->state.safe_script_file(script, sandbox);
    }

private:
    LuaRuntime *runtime = {nullptr};
    sol::environment sandbox;
};
```

И вот теперь, наконец-то, можно переходить к библиотекам.

Мы уже выяснили, что содержимое библиотек грузить придётся выборочно. Насколько выборочно - тоже уже определили. Остаётся только задать соответствующие правила для каждой из библиотек.
```cpp
class LuaSandbox
{
    ...
private:
    using LibNames = std::vector<std::string_view>; // Да - vector,
                                                    // да - динамическая аллокация,
                                                    // да - "но геймдев же...", 
                                                    // и да - нужно переделать на constexpr
                                                    // но, чтобы не усложнять - пока оставим

    struct LibSymbolsRules
    {
        LibNames allowed{};                     // Белый список
        LibNames restricted{};                  // Чёрный, соответственно
        bool allowedAllExceptRestricted{false}; // Определяет какой из списков используется
    };
    using LibsSandboxingRulesMap = std::map<sol::lib, LibSymbolsRules>; // Да map,
                                                                        // и далее по списку )

    // И да, это определение потом придётся вынести в cpp-файл
    inline static const LibsSandboxingRulesMap libsSandboxingRules = {
        {sol::lib::base,
            {.allowed = {"assert", "error", "ipairs", "next", "pairs",
                         "pcall", "select", "tonumber", "tostring",
                         "type", "unpack", "_VERSION", "xpcall"}}},
        {sol::lib::coroutine,
            {.allowedAllExceptRestricted = true}},
        {sol::lib::math,
            {.allowedAllExceptRestricted = true,
             .restricted = {"random", "randomseed"}}},
        {sol::lib::os, 
            {.allowed = {"clock", "difftime", "time"}}},
        {sol::lib::string,
            {.allowedAllExceptRestricted = true,
             .restricted = {"dump"}}},
        {sol::lib::table,
            {.allowedAllExceptRestricted = true}}
    };
    ...
};
```

На этом с правилами закончили. Теперь, в соответствии с ними, нужно загрузить сами библиотеки.

Так как мы оперируем библиотеками как `sol::lib`, то нам понадобится хелпер для получения реального, Lua-имени:
```cpp
// Заведём отдельный неймспейс для всякого рода вспомогательных функций.
namespace lua   
{
    namespace details
    {
		struct LibName
		{
			sol::lib lib;
			std::string_view name;
		};
		constexpr auto libsNames = std::to_array({
			{sol::lib::base,      "base"},
			{sol::lib::bit32,     "bit32"}, // Lua 5.2+
			{sol::lib::coroutine, "coroutine"},
			{sol::lib::debug,     "debug"},
			{sol::lib::ffi,       "ffi"}, // LuaJIT only
			{sol::lib::io,        "io"},
			{sol::lib::jit,       "jit"}, // LuaJIT only
			{sol::lib::math,      "math"},
			{sol::lib::os,        "os"},
			{sol::lib::package,   "package"},
			{sol::lib::string,    "string"},
			{sol::lib::table,     "table"},
			{sol::lib::utf8,      "utf8"} // Lua 5.3+
		});
    } // namespace details

    // Собственно сам хелпер.
	constexpr auto libName(sol::lib lib) noexcept -> std::optional<std::string_view>
	{
		auto findLib = [lib](auto &lookup) -> bool { return lookup.lib == lib; };
		
		const auto &libs = lua::details::libsNames;
		if (auto it = ranges::find_if(libs, findLib); it != libs.end()) {
			return it->name;
		}
		return std::nullopt;
	}

    // Ну и чтобы два раза не вставать, сразу добавим обратный.
	constexpr auto libByName(std::string_view libName) noexcept -> std::optional<sol::lib>
	{
		auto findLibName = [libName](auto &lookup) -> bool { return lookup.name == libName; };

		const auto &libs = lua::details::libsNames;
		if (auto it = ranges::find_if(libs, findLibName); it != libs.end()) {
			return it->lib;
		}
		return std::nullopt;
	}
} // namespace lua
```
Ну и наконец, сам загрузчик:
```cpp
class LuaSandbox
{
    ...
private:
    void copyLibFromState(sol::lib lib, const LibSymbolsRules &rules);
    ...
};

void LuaSandbox::copyLibFromState(sol::lib lib, const LibSymbolsRules &rules)
{
	// Определяемся с именем таблицы, где обитает запрошенная библиотека.
    const auto libLookupName = lua::libLookupName(lib);
	if (libLookupName.empty()) {
		return;
	}
    // Копировать будем отсюда,
	const sol::table src = runtime->state[libLookupName]; 

    // проверив, на всякий случай, что таблица таки существует.
    if (!src.valid()) {
		return;
	}

    // Функции из 'base' заливаются прямо в '_G', который у нас уже есть,
    // для остальных же библиотек придётся создать свои таблицы для копирования.
	if (lib != sol::lib::base) {
		sandbox[libLookupName] = sol::table(runtime->state, sol::create);
	}
    // Сюда.
	sol::table dst = sandbox[libLookupName];

    // Ну и, собственно, то, к чему мы так долго и тернисто шли - заливаем в песочницу,
    if (rules.allowedAllExceptRestricted) {
        // копируя вообще всё содержимое поэлементно,
		for (const auto &[name, object] : src) {
			dst[name] = object;
		}
        // и удаляя запрещёнку.
		for (const auto &name : rules.restricted) {
			dst[name] = sol::nil;
		}
	} else { // Ну или, в случае белого списка,
        // просто грузим только разрешённое.
		for (const auto &name : rules.allowed) {
			dst[name] = src[name];
		}
	}
}

// И чуть не забытый хелпер
namespace lua
{
    // для определения имени таблицы - местоположения библиотеки внутри Lua-стейта.
	constexpr auto libLookupName(sol::lib lib) -> std::string_view
	{
		// Функции из `base` сидят прямо в "корне" - '_G', в отличие от остальных библиотек.
        return (lib == sol::lib::base) ? "_G" : lua::libName(lib).value_or("");
	}
}  // namespace lua
```
И завершаем картину с библиотеками последними штрихами - интерфейс для их загрузки:
```cpp
// Кстати, С++ - это очень элегантный и выразительный язык.
// Например, обратите внимание, на эту лаконичную запись синонима для 
// "Какой-нибудь контейнер с sol::lib внутри"
template <typename T>
concept SolLibContainer =
    std::ranges::range<T>
    && std::same_as<std::remove_cvref_t<std::ranges::range_value_t<T>>, sol::lib>;

// Библиотеки можем грузить сразу пачкой
void LuaSandbox::loadLibs(const SolLibContainer auto &libs)
{
    for (const auto &lib : libs) {
        loadLib(lib);
    }
}

// или по одной.
bool LuaSandbox::loadLib(sol::lib lib)
{
    const auto rules = checkRulesFor(lib); // Для неё правила есть вообще?
    if (!rules) {
        return false;
    }
    // Запрос на загрузку библиотеки в Lua-стейт.
    // Нам же нужно её откуда-то в песочницу подтягивать
    runtime->require(lib)ж

    copyLibFromState(lib, *rules);
    loadedLibs.insert(lib); // Учёт загруженных библиотек

    return true;
}

// Просто проверка на наличие правил для конкретной библиотеки
auto LuaSandbox::checkRulesFor(sol::lib lib) const noexcept
    -> opt_cref<LibSymbolsRules>
{
    if (const auto it = libsSandboxingRules.find(lib); it =! libsSandboxingRules.end()) {
        return it->second;
    }
    return std::nullopt;
}

class LuaSandbox
{
    ...
public:
    void loadLibs(const SolLibContainer auto &libs);
    bool loadLib(sol::lib lib);

private:
    auto LuaSandbox::checkRulesFor(sol::lib lib) const noexcept
        -> opt_cref<LibSymbolsRules>

    std::set<sol::lib> loadedLibs; // Список уже загруженных библиотек
    // ... опять?
    // Да, std::set. Да - динамическая аллокация... и дальше по списку.
    // ~~Расстреля~~ Переделать. И в LuaRuntime тоже.
    ...
};
```
Здесь может несколько смутить возвращаемый тип `opt_cref<LibSymbolsRules>` для `checkRulesFor`, но это просто константный `std::optional` для `&`ссылок, который в C++ не завезли.

<details>
<summary> Реализация, если интересно. </summary>

```cpp
template <typename T>
class [[nodiscard]] optional_ref
{
public:
    optional_ref() = default;
    optional_ref(std::nullopt_t) : ref(std::nullopt) {}
    optional_ref(T &value) : ref(value) {}

    explicit operator bool() const noexcept { return has_value(); }

    T &operator*() noexcept { return ref->get(); }
    const T &operator*() const noexcept { return ref->get(); }

    T *operator->() noexcept { return std::addressof(**this); }
    const T *operator->() const noexcept { return std::addressof(**this); }

    bool operator==(std::nullopt_t) const noexcept { return !has_value(); }
    bool operator!=(std::nullopt_t) const noexcept { return has_value(); }

    bool has_value() const noexcept { return ref.has_value(); }

    void reset() noexcept { ref.reset(); }

private:
    std::optional<std::reference_wrapper<T>> ref;
};

template <typename T>
using opt_ref = optional_ref<T>;

template <typename T>
using opt_cref = optional_ref<const T>;
```

</details>

---


Вспоминаем про нашу параною и позволим создавать песочницы только по заранее заданным шаблонам, ограничивающим список загружаемых библиотек.
Все животные равны, но некоторые равнее - поэтому добавим шаблон `Custom`, для которого, мало того, что весь список библиотек досупен, так ещё и позволяет загружать их по мере необходимости, а не в момент создания песочницы.

```cpp
class LuaSandbox
{
public:
    enum class Presets { Core, Minimal, Complete, Custom };

    // Чуть доработаем наш конструктор
    // Чтобы без указания шаблона нельзя было создать песочницу
    explicit LuaSandbox(LuaRuntime &state,
                        Presets preset)
        : lua(state),
          preset(preset)
    {...}

    // Ad-hoc загрузка библиотек для его величества Presets::Custom
    bool LuaSandbox::require(sol::lib lib)
    {
        if (preset == Presets::Custom) {
            return loadLib(lib);
        }
        return false;
    }
    ...

private:
    ...
    Presets preset{Presets::Core};

    using SandboxPresets = std::map<Presets, Libs>;
    inline static const SandboxPresets sandboxPresets{
        {Presets::Core, {}},
        {Presets::Minimal,
            {sol::lib::base,
             sol::lib::table}},
        {Presets::Complete,
            {sol::lib::base,
             sol::lib::coroutine,
             sol::lib::math,
             sol::lib::os,
             sol::lib::string,
             sol::lib::table}},
        {Presets::Custom, {}}
    };
};

// Добавим в reset() загрузку библиотек после сброса.
// И, т.к. он у нас несколько распух - вынесем в cpp-файл.
void LuaSandbox::reset(bool doCollectGrbg /* = false */)
{
    sandbox = sol::environment(lua->state, sol::create);
    sandbox["_G"] = sandbox;

    if (loadedLibs.empty()) { 
        // Для конструктора используем список из пресета.
        loadLibs(sandboxPresets.at(preset));
    } else {
        // Если же инкарнация уже не первая, то грузим всё, что было в прошлой жизни.
        loadLibs(loadedLibs);
    }
    // Принудительная уборка мусора, в случае необходимости
    if (doCollectGrbg) {
        lua->state.collect_garbage();
    }
}
```

С основным, вроде разобрались.
Что у нас там дальше по списку? Возможность запуска файлов со скриптами из самих скриптов.

В Lua это осуществляется двумя путями - через `loadfile`/`dofile` или `require`. Первые два живут в библиотеке `base`, последний в `package`. Напомню, что ни одину из этих функцмй мы в песочницу не грузим, а родной `require`, так и вовсе со всей библиотекой игнорируем по соображениям безопасности.

`loadfile` просто загружает указанный файл, компилирует его в байткод и возвращает как функцию, но не запускает на выплонение. `dofile` же, и загружает _(через тот же самый 'loadfile')_ и запускает. Оба они живут в `base` библиотеке.

`requre` же, это - механизм Lua для загрузки модулей. Он, помимо, собственно скриптов `.lua` может загружать и уже скомпилированный Lua-байткод _(в данном аспекте, кстати, `loadfile` от него тоже не отстаёт)_, и даже обычные динамические C-библиотеки `.so/.dll/.dylib`. Это всё прямо из коробки. А если ещё добавить свои загрузчики, то вообще любой формат - будь то JSON, архив или бинарный код. _Вот уж где нашим юным натуралистам, действительно, есть где разгуляться._ 

Кроме того, у `require` есть пара ключевых отличий от `loadfile`, на которых придётся остановиться чуть подробнее, так как они важны для нашей реализации:

- для того, чтобы загрузить модуль, нам абсолютно не нужно знать где именно тот сидит в файловой системе - достаточно просто указать его имя и `require` сам полезет его искать. И даже больше - `require` в принципе не сможет корректно обработать в качестве своего аргумента имя модуля с явным указанием пути к нему. А вот для `loadfile` пути нужно указывать явно:

  `loadfile("path/to/our/modules/rocket_science.lua")`

  vs 

  `require("rocket_science")`

  На отсутствие расширения во втором варианте внимание же тоже обратили, да? Это не ошибка - это ещё одна особенность, которую нужно учитывать.


  

- `require` не просто загружает файл, он задействует механизм кеширования уже подтянутых модулей и, при повторном запросе, просто подсовывает их из кеша


---



## Что пока не охвачено данной реализацией.

1. Защита от зависаний на стороне lua-скриптов: решается через хуки и таймауты - если скрипт выполняется дольше чем разрешено таймаутом, то скрипт просто прибивается. Да, это не решает проблему неработоспособности скрипта, но, по крайней мере, даёт возможность нашему движку отработать ошибку и работать дальше, не вылетев из-за кривого мода/карты. 
2. Защита от отжора памяти.
3. Механизм контроля целостности доверенных скриптов - например, скриптов, поставляемых нами самими. Со скриптами модов пользователь может делать что угодно, но для гарантированной работоспособности движка его скрипты трогать не стоит.
4. Hotreload - по факту изменения .
