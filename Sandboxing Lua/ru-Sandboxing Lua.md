# Заметки на полях: Изолируем Lua окружение в C++ приложении.
tags: c++, lua, gamedev, sol2

## Введение
Для начала накинем немного контекста.
- Во-первых, в качестве C++ хоста у нас выступает игровой движок, где скриптовый язык нужен для конфигов, логики, модов и вот этого вот всего.
- Во-вторых, нужна возможность запуска сторонних, написанных не нами (читай непроверенных и потенциально небезопасных) скриптов.
- В-третьих, исходя из вышеобозначенного, очень желательно свести к минимуму возможности нашкодить, со стороны особенно любознательных пользователей, очень творческих мододелов и просто мамкиных кулхацкеров;
- В-четвёртых, берём как данность, что автор этих строк от природы откровенно ленив и, поэтому, по максимуму стараемся использовать уже готовые решения.

Опустим рассуждения о достоинствах и недостатках Lua в качестве скриптового языка, а так же обзор возможных вариантов его подключения к нашему приложению - для этого есть уйма статей, написанных такими корифеями, что я даже смысла не вижу залезать на эту поляну. А, просто, возьмём как данность, что выбор в итоге остановили на:
- Lua 5.1/LuaJIT: Версии после 5.1 показывают деградацию по скорости выполнения _(у нас же геймдев)_, а JIT-версия, в принципе остановилась в своём развитии на этапе 5.1;
- Для подключения используем библиотеку `sol2`: Однозначно - Жемчужина, которая просто до неприличия упрощает взаимодействие с Lua. Опять же, без ущерба скорости _(ну геймдев же, ну)_;
- Ну и C++20, просто потому, что есть такая возможность.


## Реализация

Для выполнения Lua-кода из нашего приложения необходимо создать для него окружение - фактически виртуальную машину, содержащую всё необходимое для запуска скриптов - стек, глобальные переменные, таблицы и функции, а также аллокатор и сборщик мусора. В терминологии Lua это называется **_state_** (состояние).

Создание всего этого - задача, конечно, довольно нетривиальная и, в нашем случае, решается
<details>
<summary> через...[click]</summary>

Добавление двух строк )
```cpp
#include <sol/sol.hpp>

sol::state lua;
```
</details>

-----

Собственно, уже на этом этапе в нашем распоряжении - синтаксис и базовая семантика, циклы и операторы ветвления, логика и арифметика, таблицы и возможность определять свои функции.

Чего с головой хватит для описания большей части данных, что нам может понадобиться - юниты, инвентарь, диалоги, карты, описание уровней, UI, графика, звуки и чего только не.

```lua
-- Lua
-- config_screen.lua

local screen = {
    width = 1280,
    height = 720,
    presets = {
        ["HD"]  = {1280, 720},
        ["FHD"] = {1920, 1080},
        ["4K"]  = {3840, 2160},
        default = "HD"
    }
}
function getScreenPreset(preset)
    local presets = screen.presets
    return presets[preset] or presets[presets.default]
end

return screen
```
```cpp
// Cpp

auto screenCfg = lua.script_file("config_screen.lua");

// доступ к элементам Lua-таблицы по ключу
int width = screenCfg["width"];
int height = screenCfg["height"];

std::cout << std::format("Configured screen resolution: {}x{}\n", width, height);
// --> Configured screen resolution: 1280x720

// можем вызывать функции объявленные в Lua
auto preset = lua["getScreenPreset"]("FHD");

// Доступ по индексу
width = preset[1]; // И да, индексация в Lua начинается c 1
height = preset[2];

std::cout << std::format("FHD resolution: {}x{}\n", width, height);
// --> FHD resolution: 1920x1080
```
А, реализовав недостающий функционал на стороне C++, и, пробросив его в Lua, можно уже замахиваться на игровую логику.
```cpp
// Cpp
namespace math
{
    int add(int a, int b) { return a + b; };
}

auto api = lua.create_table();

api["add"] = math::add;
api["sub"] = [](int a, int b) { return a - b; };

lua["engineAPI"] = api;

lua.script_file("script.lua");

int a = lua["a"];
std::cout << std::format("a:{}, b:{}\n", a, lua["b"].as<int>());
// --> a:30, b:-10
```
```lua
-- Lua
-- script.lua

a = engineAPI.add(10, 20)
b = engineAPI.sub(10, 20)
```
И на этом можно было бы уже заканчивать.

Но.

У нас уже не мало доступного функционала, а вот возможностей чувствительно нашкодить в скриптах ещё не очень _(Кстати, какие варианты приходят в голову? В комментах писать не надо - а то подглянут ещё)_. Я  бы, всё-таки, расширил пространство для манёвра любителям, скажем так, нестандартных решений - ну так, чисто ради подогрева интереса. Это во-первых.

Во-вторых, у нас, в самом начале, в исходных данных была обозначена природная лень. Следовательно, рожать велосипед самостоятельно повторяя функционал стандартных библиотек - ну серьёзно?

Ну а в-третьих, это было бы слишком просто и смысла даже начинать  данную заметку не было. Но если посмотреть на ползунок прокрутки справа, то текста там там ещё порядком. Поэтому придётся продолжать. 


## Стандартные Lua библиотеки
Для начала коротко пробежимся по тому, что же они нам предлагают - а то, может, действительно не стоит заморачиваться?


| Библиотека | Назначение | Функционал / Описание |
|-------------|-------------|------------------------|
| **base** | Базовые возможности языка | Основные конструкции Lua: работа с типами, проверка и преобразование значений, обработка ошибок, итерация по таблицам, **выполнение кода из строк или файлов** и базовые средства метапрограммирования. |
| **package** | Система модулей | **Организация и загрузка Lua- и C-модулей, подключенние библиотек.** |
| **string** | Работа со строками | Изменение, поиск и шаблонное сопоставление строк, конкатенация, форматирование, преобразование регистра. |
| **table** | Манипуляции с таблицами | Работа с таблицами: сортировка, объединение, вставка, удаление, копирование, преобразование таблиц в строки и обратно. |
| **math** | Математика и случайность | Арифметические, тригонометрические и логарифмические функции, округление, генерация случайных чисел, операции с целыми. |
| **io** | Ввод-вывод | Работа с файлами и стандартными потоками: **открытие, чтение, запись, построчная обработка**, управление буферами. |
| **os** | Доступ к функциям ОС | Работа со временем, датой, **окружением, файлами и системными командами. Позволяет взаимодействовать с внешней средой.** |
| **coroutine** | Кооперативная многозадачность | Создание и управление корутинами: приостановка и возобновление выполнения, реализация последовательных сценариев. |
| **debug** | Отладка | **Доступ к стеку вызовов, локальным переменным и функциям. Используется для профайлинга и инструментов разработки.** |


Из полезных есть ещё **utf8** и **bit32**. Первая, как ни странно, для работы с кодировкой UTF8, вторая - реализация битовых операций. Но их завезли уже после Lua 5.1, поэтому игнорируем. Да, битовых операций в 5.1 нет. Совсем.

Даже беглого просмотра достаточно для того чтобы понять - брать надо. Но с осторожностью - в описании жирным выделен небезопасный функционал.

Если же [копнуть чуть глубже](http://lua-users.org/wiki/SandBoxes), то вырисовывается вполне себе чёткая картина - для части библиотек содержимое придётся загружать выборочно, а для некоторых даже их название вслух произносить небезопасно. Поэтому последние просто игнорируем, а если уж совсем приспичит - их функционал придётся реализовывать самостоятельно _(тот же доступ к файловой системе, можно ограничить только на чтение, и только в пределах разрешённых путей)_.

- **debug** - вообще без вариантов, даже палкой трогать не будем;
- **io** - действительно, почему бы не дать сомнительным скриптам доступ к файловой системе?
- **os** - оставляем только функции для доступа ко времени;



## Что пока не охвачено данной реализацией.

1. Защита от зависаний на стороне lua-скриптов: решается через хуки и таймауты - если скрипт выполняется дольше чем разрешено таймаутом, то скрипт просто прибивается. Да, это не решает проблему неработоспособности скрипта, но, по крайней мере, даёт возможность нашему движку отработать ошибку и работать дальше, не вылетев из-за кривого мода/карты. 
2. Защита от отжора памяти.
3. Механизм контроля целостности доверенных скриптов - например, скриптов, поставляемых нами самими. Со скриптами модов пользователь может делать что угодно, но для гарантированной работоспособности движка его скрипты трогать не стоит.
4. Hotreload.
