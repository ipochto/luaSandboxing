# Заметки на полях: Изолируем Lua окружение в C++ приложении.
tags: c++, lua, gamedev, sol2

Скриптовые языки уже давно и прочно заняли свою нишу в игрострое — они существенно упрощают описание игровой логики, уровней, ресурсов, диалогов, квестов, UI и чего только не. Что позволяет отдать эти задачи целиком и полностью в творческие руки гейм-/левел-/прочих-дизайнеров и других членов команды, которым не нужно обладать знаниями в том же C++. Разделение ответственности, ускорение разработки, облегчение моддинга, ~~возможность по завершению разработки самого движка вышвырнуть программистов на мороз и стричь купоны на бесконечных дополнениях~~ — в общем, одни только плюсы. Да?

Да.

А ещё дыры в безопасности и уйма путей уронить стабильность.

В замечательном цикле статей "Game++" от @dalerank, а если быть конкретней, то в [Game++. while (!game(over))](https://habr.com/ru/articles/907146/) озвучена следующая мысль про скрипты в игровых движках, как раз на эту тему:

> ***... на удивление, [скрипты — ] это про безопасность***\
*Скрипты обычно запускаются в изолированной среде. Это значит, что если моддер написал что-то странное — он сломает только свою миссию, а не всю игру. Можно ограничить доступ скриптам: дать им возможность работать только с теми объектами, которые тебе нужны. Настроить лимиты, интерпретировать исключения, и в крайнем случае — просто не запускать подозрительное. В плюсах такой гибкости не получишь. Там любой кривой плагин — это потенциальный краш.*

То есть лечится.

## Но, блин, КАК?

К сожалению, ответ на этот вопрос выходил далеко за рамки статьи, поэтому придётся разбираться самостоятельно.

- [Библиотеки](#libraries-anchor)
- [Загрузка скриптов](#scripts-anchor)
- [Hello world](#hello-world-anchor)
- [Память](#allocators-anchor)
- [Время выполнения](#timeoutGuard-anchor)

## Постановка задачи
Для начала накинем немного контекста:
- Во-первых, в качестве C++ хоста у нас выступает игровой движок, где скриптовый язык нужен для конфигов, логики, модов и вот этого вот всего.
- Во-вторых, нужна возможность запуска сторонних, написанных не нами (читай: непроверенных и потенциально небезопасных) скриптов.
- В-третьих, исходя из выше обозначенного, очень желательно свести к минимуму возможности нашкодить со стороны особенно любознательных пользователей, очень творческих мододелов и просто мамкиных кулхацкеров.
- В-четвёртых, берём как данность, что автор этих строк от природы откровенно ленив, и поэтому по максимуму стараемся использовать уже готовые решения.

Опустим рассуждения о достоинствах и недостатках Lua в качестве скриптового языка, а также обзор возможных вариантов его подключения к нашему приложению — для этого есть уйма статей, написанных такими корифеями, что я даже смысла не вижу залезать на эту поляну. Просто возьмём как данность, что выбор в итоге остановили на:
- Lua 5.1/LuaJIT: Ибо LuaJIT покрывает все остальные версии по производительности, даже с отключённым JIT _(а у нас же геймдев)_. Но, к сожалению, она в принципе остановилась на этапе Lua 5.1 _(с некоторыми оговорками)_, поэтому ориентироваться будем на синтаксис и набор библиотек, актуальный на тот момент. Тем не менее жёстко к LuaJIT-специфичным нюансам не привязываемся и стараемся все решения делать максимально универсальными, ну или требующими минимальных доработок.
- Для подключения используем `sol2` — невероятно вкусная библиотека, которая просто до неприличия упрощает взаимодействие с Lua. Опять же, без ущерба скорости _(ну геймдев же, ну)_;
- Ну и C++20. Просто потому, что есть такая возможность. Впрочем, всё, описанное ниже, вполне реализуемо и на более взрослых версиях стандарта.

## По пути наименьшего сопротивления

Для выполнения Lua-кода из нашего приложения необходимо создать для него окружение — фактически виртуальную машину, содержащую всё необходимое для запуска скриптов: стек, глобальные переменные, таблицы и функции, а также аллокатор и сборщик мусора. В терминологии Lua это называется **_state_** (состояние).

Создание всего этого — задача, конечно, довольно нетривиальная.
<details>
<summary> И, в нашем случае, решается через... [развернуть]</summary>

```cpp
// Добавление аж двух строк )
#include <sol/sol.hpp>
sol::state lua;
```
</details>

-----

Собственно, уже на этом этапе в нашем распоряжении синтаксис и базовая семантика, циклы и операторы ветвления, логика и арифметика, таблицы и возможность определять свои функции.

Чего с головой хватит для описания большей части данных, которые нам могут понадобиться: юниты, инвентарь, диалоги, карты, описание уровней, UI, графика, звуки и чего только не.

```lua
-- Lua
-- config_screen.lua

local screen = {
    width = 1280,
    height = 720,
    presets = {
        ["HD"]  = {1280, 720},
        ["FHD"] = {1920, 1080},
        ["4K"]  = {3840, 2160},
        default = "HD"
    }
}
function getScreenPreset(preset)
    local presets = screen.presets
    return presets[preset] or presets[presets.default]
end

return screen
```

```cpp
// Cpp
auto screenCfg = lua.script_file("config_screen.lua");

// доступ к элементам Lua-таблицы по ключу
int width = screenCfg["width"];
int height = screenCfg["height"];

std::cout << std::format("Configured screen resolution: {}x{}\n", width, height);
// --> Configured screen resolution: 1280x720

// можем вызывать функции, объявленные в Lua
auto preset = lua["getScreenPreset"]("FHD");

// Доступ по индексу
width = preset[1]; // И да, индексация в Lua начинается c 1
height = preset[2];

std::cout << std::format("FHD resolution: {}x{}\n", width, height);
// --> FHD resolution: 1920x1080
```

А реализовав недостающий функционал на стороне C++, и пробросив его в Lua, можно уже замахиваться на игровую логику.

```cpp
// Cpp
namespace math
{
    int add(int a, int b) { return a + b; };
}

auto api = lua.create_table();

api["add"] = math::add;
api["sub"] = [](int a, int b) { return a - b; };

lua["engineAPI"] = api;

lua.script_file("script.lua");

int a = lua["a"];
std::cout << std::format("a:{}, b:{}\n", a, lua["b"].as<int>());
// --> a:30, b:-10
```

```lua
-- Lua
-- script.lua

a = engineAPI.add(10, 20)
b = engineAPI.sub(10, 20)
```
И на этом можно было бы уже заканчивать.

Но.

У нас уже немало доступного функционала, а вот возможностей чувствительно нашкодить в скриптах ещё не очень _(Кстати, какие варианты приходят в голову? В комментах писать не надо — а то подглянут ещё)_. Я бы всё-таки расширил пространство для манёвра любителям, скажем так, нестандартных решений — ну так, чисто ради подогрева интереса. Это, во-первых... А если серьёзно, у нас напрочь отсутствует возможность вызывать сторонние скрипты из самих скриптов, а это сразу — здравствуй потеря модульности и архитектурной гибкости _(и это для игрового-то движка)_, грабли с условной динамической загрузкой, повышенная нагрузка на API движка _(ну ладно, ладно — читать как "на разработчиков этого самого API")_.

Во-вторых, у нас в самом начале, в исходных данных была обозначена природная лень. Следовательно, рожать велосипед самостоятельно, повторяя функционал стандартных библиотек — ну серьёзно?

Ну а в-третьих, это было бы слишком просто, и даже начинать данную заметку не имело бы смысла. Но если посмотреть на ползунок прокрутки справа, то текста там ещё порядком. Поэтому придётся продолжать.

<a id="libraries-anchor"></a>

## Тишина должна быть в библиотеке (c)

Здесь придётся чуть подробнее остановиться на том, что, собственно, представляет из себя загрузка библиотек в Lua.

<details>
<summary> Но начнем мы, как ни странно, с таблиц. [развернуть]</summary>

*Можно смело пропустить, если в курсе внутренней кухни Lua.

В Lua таблицы — это единый и универсальный механизм данных и структурирования, на котором фактически строится вообще весь язык. Они могут хранить значения любого типа: числа, строки, другие таблицы и **функции**. И не просто могут — вообще все переменные, функции, библиотеки и модули являются именно элементами таблиц.

Тип у Lua таблиц является ссылочным, т.е. когда мы присваиваем переменной или передаём в функцию какую-нибудь таблицу, копирования не происходит — присваивается и передаётся только ссылка. Если такая переменная выходит из области видимости или ей присваивается `nil` — ссылка обнуляется. А когда ссылок на нашу таблицу вообще не остаётся, она с чистой совестью выпиливается сборщиком мусора. Очевидно, что у нас должна быть какая-то главная таблица, не удаляемая сборщиком, и в которой мы сможем создавать ссылки на новые.

И вот тут создатели языка подошли с фантазией. Они сделали её неявной, т.е. она есть, и вы можете даже обратиться к ней по имени, но это совсем не обязательно. Вы можете спокойно писать на Lua, даже не подозревая о её существовании. Конечно, есть несколько сценариев, когда явное обращение таки потребуется, но это уже для тех, кто действительно знает, что делает.

Ещё раз: основная точка входа в Lua — скрыта от пользователя, даёт работать с языком, даже не зная о месте её нахождения, а явное обращение к ней в умелых руках позволяет делать нетривиальные вещи.

Есть идеи для названия?
</details>

---

Её величество **`_G`**. Это переменная, содержащая ссылку на предопределённую таблицу глобального окружения. И абсолютно все глобальные переменные и функции являются полями этой таблицы.

```lua
-- Lua
x = 42
print(x)       --> 42
print(_G.x)    --> 42
_G.print(_G.x) --> 42
```

И именно в `_G` загружаются библиотеки, которые представляют из себя не что иное, как просто таблицы с функциями _(упростил, да)_. Создаётся глобальная переменная, и в неё кладётся ссылка на соответствующую таблицу. Всё.

```cpp
// Cpp
sol::state lua;

// Собственно, загрузка библиотек
lua.open_libraries(sol::lib::base, sol::lib::math);

lua.script(R"(
    print("#1 " .. math.max(10, 42, -1))
    print("#2 " .. _G.math.max(10, 42, -1))
)");
// --> #1 42
// --> #2 42
```

За редким исключением, правда — например, функции из `base` кладутся прямо в `_G` — "корень" глобальной области видимости *(тот же `print`, а не `base.print` из примера выше)*, или функция `require`, которую `package` тоже закидывает прямо в `_G`, в отличие от всех остальных своих функций.

Дальше, в Lua нет механизма частичной загрузки библиотек. Первое, что приходит на ум:

```cpp
// Cpp
lua.open_libraries(sol::lib::os);

// просто обнулить опасные функции
os["execute"] = sol::nil
os["remove"] = sol::nil
...
```

Но есть более гибкий вариант — механизм подмены таблицы глобального окружения, который позволяет запускать код в окружении, изолированном от основного Lua-стейта, т.е. в песочнице. В `sol2` это реализуется через `sol::environment`.

```cpp
// Cpp
lua::state lua;
lua::environment sandox(lua, sol::create);
sandbox["_G"] = sandbox;

lua.script_file("script.lua", sandbox);
```

И вот в неё-то мы уже можем спокойно пробросить только те части библиотек, которые посчитаем нужными.

```cpp
// Cpp
lua::state lua;
lua::environment sandox(lua, sol::create);
sandbox["_G"] = sandbox;

const auto checkWhere = R"(
    if print then
        print (whereAmI)
    else
        houston()
    end
)";

auto houston = []() {
    std::cout << "Houston, we have a problem.\n";
};

lua["whereAmI"] = "In a Lua state";
lua["houston"] = houston;

sandbox["whereAmI"] = "In a sandbox";
sandbox["houston"] = houston;

lua.script(checkWhere); // --> Houston, we have a problem.

// Теперь загружаем библиотеку
lua.open_libraries(sol::lib::base);

lua.script(checkWhere); // --> In a Lua state

// *Явно указываем окружение, в котором нужно выполнить
lua.script(checkWhere, sandbox);  // --> Houston, we have a problem.

sandbox["print"] = lua["print"];
lua.script(checkWhere, sandbox); // --> In a sandbox
```

Кстати, тут есть один нюанс. Дело в том, что вот эта запись в Lua:

```cpp
sandbox["libname"] = lua["libname"];
```

это — не копирование, а ссылка на объект. Поэтому, даже если мы хотим разрешить в песочнице библиотеку целиком, то всё равно придётся переносить её содержимое поэлементно, а не через проброс всей библиотечной таблицы.

- Во-первых, библиотека может содержать какие-либо неявные, потенциально небезопасные поля, а Lua позволяет обойти их все простым перебором, даже не зная имён. Да, `_G` это, кстати, тоже касается.
- Во-вторых, это как раз одна из тех самых возможностей нашкодить: доступ к корневой таблице библиотеки позволяет подменять её функции. В случае же поэлементного проброса подмена, конечно, тоже возможна, но это затронет только песочницу — испортится только ссылка на элемент, оставив саму библиотеку невредимой.

Использование `sol::environment` открывает нам ещё несколько возможностей: например, на одном Lua-стейте делать сразу несколько независимых песочниц — хоть по отдельной на каждый запускаемый скрипт. Что существенно облегчает задачу по реализации обмена данными между песочницами. Или при сбросе песочницы _(например, перезапуск миссии)_ не нужно подгружать все библиотеки заново — мы просто заменяем таблицу-окружение на новую и копируем в неё разрешённые элементы. Ну и наконец, в случае необходимости, для доверенных скриптов в нашем распоряжении оказывается ещё и полнофункциональная версия Lua _(сам Lua-стейт)_. Последнее использовать с оговорками и осторожностью, но тем не менее возможность такая есть.

Теперь, собственно, библиотеки. Кратко пробежимся по тому, что же они нам предлагают — а то, может, действительно не стоит заморачиваться?

| Библиотека | Назначение | Функционал / Описание |
|-------------|-------------|------------------------|
| **base** | Базовые возможности языка | Основные конструкции Lua: работа с типами, проверка и преобразование значений, обработка ошибок, итерация по таблицам, **выполнение кода из строк или файлов** и базовые средства метапрограммирования. |
| **package** | Система модулей | **Организация и загрузка Lua- и C-модулей, подключение библиотек.** |
| **string** | Работа со строками | Изменение, поиск и шаблонное сопоставление строк, конкатенация, форматирование, преобразование регистра. |
| **table** | Манипуляции с таблицами | Работа с таблицами: сортировка, объединение, вставка, удаление, копирование, преобразование таблиц в строки и обратно. |
| **math** | Математика и случайность | Арифметические, тригонометрические и логарифмические функции, округление, генерация случайных чисел, операции с целыми. |
| **io** | Ввод-вывод | Работа с файлами и стандартными потоками: **открытие, чтение, запись, построчная обработка**, управление буферами. |
| **os** | Доступ к функциям ОС | Работа со временем, датой, **окружением, файлами и системными командами. Позволяет взаимодействовать с внешней средой.** |
| **coroutine** | Кооперативная многозадачность | Создание и управление корутинами: приостановка и возобновление выполнения, реализация последовательных сценариев. |
| **debug** | Отладка | **Доступ к стеку вызовов, локальным переменным и функциям. Используется для профайлинга и инструментов разработки.** |

Из полезных есть ещё **utf8** и **bit32**. Первая, как ни странно, для работы с кодировкой UTF8, и появилась она начиная с версии 5.3. Вторая — реализация битовых операций, но она была только в ветке 5.2, в 5.3 битовые операции уже напрямую в язык завели и надобность в данной библиотеке отпала. И да, битовых операций в 5.1 не было. Совсем.

Даже беглого просмотра достаточно, чтобы понять — брать надо. Но с осторожностью: в таблице в описании **жирным** выделен небезопасный функционал. Вырисовывается вполне себе чёткая картина — для части библиотек содержимое придётся загружать выборочно, а для некоторых — даже их название вслух произносить небезопасно. Поэтому последние просто игнорируем, но если уж совсем приспичит — их функционал придётся реализовывать самостоятельно на стороне движка _(тот же доступ к файловой системе, можно ограничить только на чтение, и только в пределах разрешённых путей)_.

Если же копнуть глубже, то в итоге у нас вырисовывается следующая картина:

**Base** — мастхэв, но:
- Функционал загрузки и запуска кода на выполнение (все эти `load`, `loadstring`, `loadfile`, `dofile`) придётся взять на себя и реализовать безопасные замены самостоятельно. Этим займёмся позже.
- Кроме того, запрещаем всё, что даёт доступ к метатаблицам (`setmetatable`, `getmetatable`) и позволяет их обходить (`rawequal`, `rawget`, `rawset`). Да, метатаблицы сами по себе могут использоваться как мощный инструмент реализации ограничений для небезопасных функций, но, к сожалению, в Lua нет механизма их защиты.
- Не даём пользователю вручную вызвать сборщик мусора через `collectgarbage`.
- Блокируем возможность читать и менять окружение (`getfenv`, `setfenv`).
- И напоследок, `print` — заменим на свой вариант, чтобы можно было перенаправить вывод в поток, отличный от `stdout`.

**package** — небезопасна полностью. Единственное, стоит отдельно упомянуть `require`, которая является сильно продвинутой версией `dofile` из `base`, с поиском запрошенного файла в разрешённых путях и контролем повторной загрузки. Есть смысл тоже заменить на нашу безопасную реализацию `dofile`, добавив к ней возможность запроса на загрузку стандартных библиотек из самих скриптов.

**string** — однозначно забираем, за исключением потенциально небезопасной `dump`, которая позволяет получить байткод любой доступной функций.

**table** — целиком безопасна.

**math** — случайную генерацию (`random`, `randomseed`) лучше оставить на стороне хоста _(для мультиплеера она обычно должна быть синхронизирована для всех клиентов)_, а остальное лишним точно не будет.

**io** — действительно, почему бы не дать сомнительным скриптам доступ к файловой системе?

**os** — оставляем только функции для доступа ко времени: `clock`, `difftime` и `time`.

**coroutine** — почему бы и да! Пусть будет.

**debug** — вообще без вариантов, здесь я бы её даже палкой трогать не стал.

**utf8** и **bit32** тоже безопасны целиком, и можно добавлять, но с оглядкой на используемую версию Lua, т.к. они не во всех представлены.

## Поехали... (c)

Так, на данном этапе, похоже, что у нас уже набралась критическая масса информации, достаточная, чтобы начинать реализацию. Но, чтобы нас не разорвало в творческом порыве, пожалуй, стоит сразу обозначить основные моменты, которых будем придерживаться.


1. Песочницы реализуем через механизм подмены глобальной таблицы-окружения (`sol::environment`).
2. На одном Lua-стейте может быть несколько песочниц одновременно.
3. Если уж параноить, то до конца — песочницы могут обладать разным уровнем доверия, поэтому необходимо иметь возможность ограничения списка доступных для них библиотек. Возможность запроса библиотек из самих скриптов, вообще только самым доверенным песочницам дадим, для остальных же — загрузка по разрешённым спискам только в момент создания самой песочницы.
4. Нужен механизм сброса песочниц после использования до их изначального состояния.
5. Библиотеки грузятся в Lua-стейт целиком, а в песочницы из них пробрасываются только безопасные функции. Функции же, которые нельзя, но очень хочется использовать — заменяем своими безопасными реализациями.
7. Должна быть возможность запуска файлов со скриптами из самих скриптов. Здесь ещё придётся учитывать ограничения по доступным путям.


В первую очередь, чтобы можно было вести учёт уже загруженных библиотек и не дёргать `open_libraries()` каждый раз при создании новой песочницы, сделаем обёртку для `sol::state`.

```cpp
class LuaRuntime : public sol::state
{
public:
    sol::state state;

    LuaRuntime() = default;
    ~LuaRuntime() = default;

    // Запрещаем копирование и перенос
    LuaRuntime(const LuaRuntime &) = delete;
    LuaRuntime(LuaRuntime &&) = delete;
    LuaRuntime &operator=(const LuaRuntime &) = delete;
    LuaRuntime &operator=(LuaRuntime &&) = delete;

    // Через это будем сообщать какие библиотеки нам понадобятся в песочнице,
    // и что их было бы неплохо загрузить в Lua-стейт
    void require(sol::lib lib)
    {
        if (!loadedLibs.contains(lib)) {
            state.open_libraries(lib);
            loadedLibs.insert(lib);
        }
    }

private:
    std::set<sol::lib> loadedLibs; // Список уже загруженных библиотек.
};
```

Ну и сама песочница:

```cpp
class LuaSandbox
{
public:
    explicit LuaSandbox(LuaRuntime &runtime)
        : runtime(&runtime)
    {
        reset();
    }
    ~LuaSandbox() = default;

    // Аналогично — явно запрещаем копирование
    LuaSandbox(const LuaSandbox &) = delete;
    LuaSandbox &operator=(const LuaSandbox &) = delete;

    // Но перенос оставим, чтобы наши песочницы можно было в контейнерах хранить
    LuaSandbox(LuaSandbox &&) = default;
    LuaSandbox &operator=(LuaSandbox &&) = default;

    // Перегружаем [], чтобы снаружи был прозрачный доступ к элементам песочницы
    auto operator[](auto &&key)
    {
        return sandbox[std::forward<decltype(key)>(key)];
    }

    // Сброс через инициализацию новой песочницы
    // Старую сборщик мусора потом сам грохнет, ну или сразу, если явно попросим
    void reset(bool doCollectGarbage = false)
    {
        sandbox = sol::environment(runtime->state, sol::create);
        sandbox["_G"] = sandbox;

        if (doCollectGarbage) {
            runtime->state.collect_garbage();
        }
    }
    // Запуск скрипта на выполнение в песочнице
    auto run(std::string_view script)
        -> sol::protected_function_result
    {
        // Используем именно safe-версию, чтобы sol2 не выбрасывал нам исключения
        return runtime->state.safe_script(script, sandbox);
    }
    // И файла со скриптом, соответственно. Пока без контроля путей
    auto runFile(const std::filesystem::path &scriptFile)
        -> sol::protected_function_result
    {
        return runtime->state.safe_script_file(scriptFile, sandbox);
    }

private:
    LuaRuntime *runtime {nullptr};
    sol::environment sandbox;
};
```

Обратите внимание: вызов скриптов на выполнение в `run`/`runFile` осуществляется через `safe`-версии `script` и `script_file`. Это сделано специально, чтобы `sol2` нам не выбрасывал исключения в случае ошибки. Эти версии на выходе генерируют объект `sol::protected_function_result`, который сохраняет информацию об ошибках, что позволяет обрабатывать их вручную. Про него ниже поговорим ещё.

И вот теперь, наконец-то, можно переходить к библиотекам.

Мы уже выяснили, что содержимое библиотек грузить придётся выборочно. Насколько выборочно — тоже уже определили. Остаётся только задать соответствующие правила для каждой из библиотек.

```cpp
class LuaSandbox
{
    ...
private:
    using LibNames = std::vector<std::string_view>;

    struct LibSymbolsRules
    {
        LibNames allowed{};                     // Белый список
        LibNames restricted{};                  // Чёрный
        bool allowedAllExceptRestricted{false}; // Определяет какой из списков используется
    };
    using LibsSandboxingRulesMap = std::map<sol::lib, LibSymbolsRules>;

    static const LibsSandboxingRulesMap libsSandboxingRules;
    ...
};

const LuaSandbox::LibsSandboxingRulesMap
LuaSandbox::libsSandboxingRules{
    {sol::lib::base,
        {.allowed = {"assert", "error", "ipairs", "next", "pairs",
                     "pcall", "select", "tonumber", "tostring",
                     "type", "unpack", "_VERSION", "xpcall"}}},
    {sol::lib::coroutine,
        {.allowedAllExceptRestricted = true}},
    {sol::lib::math,
        {.allowedAllExceptRestricted = true,
         .restricted = {"random", "randomseed"}}},
    {sol::lib::os,
        {.allowed = {"clock", "difftime", "time"}}},
    {sol::lib::string,
        {.allowedAllExceptRestricted = true,
         .restricted = {"dump"}}},
    {sol::lib::table,
        {.allowedAllExceptRestricted = true}}
};
```

---

На этом с правилами закончили. Теперь, в соответствии с ними, нужно загрузить сами библиотеки.

Так как мы оперируем библиотеками как `sol::lib`, то нам понадобится хелпер для получения реального Lua-имени:

```cpp
// Заведём отдельный неймспейс для всякого рода вспомогательных функций.
namespace lua
{
    namespace details
    {
        struct LibName
        {
            sol::lib lib;
            std::string_view name;
        };
        constexpr auto libsNames = std::to_array({
            {sol::lib::base,      "base"},
            {sol::lib::bit32,     "bit32"},     // Lua 5.2 only
            {sol::lib::coroutine, "coroutine"},
            {sol::lib::debug,     "debug"},
            {sol::lib::ffi,       "ffi"},       // LuaJIT only
            {sol::lib::io,        "io"},
            {sol::lib::jit,       "jit"},       // LuaJIT only
            {sol::lib::math,      "math"},
            {sol::lib::os,        "os"},
            {sol::lib::package,   "package"},
            {sol::lib::string,    "string"},
            {sol::lib::table,     "table"},
            {sol::lib::utf8,      "utf8"}       // Lua 5.3+
        });
    } // namespace details

    // Собственно сам хелпер.
    constexpr auto libName(sol::lib lib) -> std::optional<std::string_view>
    {
        auto findLib = [lib](auto &lookup) -> bool { return lookup.lib == lib; };

        const auto &libs = lua::details::libsNames;
        if (auto it = ranges::find_if(libs, findLib); it != libs.end()) {
            return it->name;
        }
        return std::nullopt;
    }

    // Ну и чтобы два раза не вставать, сразу добавим обратный.
    constexpr auto libByName(std::string_view libName) -> std::optional<sol::lib>
    {
        auto findLibName = [libName](auto &lookup) -> bool { return lookup.name == libName; };

        const auto &libs = lua::details::libsNames;
        if (auto it = ranges::find_if(libs, findLibName); it != libs.end()) {
            return it->lib;
        }
        return std::nullopt;
    }
} // namespace lua
```

Ну и наконец, сам загрузчик:

```cpp
class LuaSandbox
{
    ...
private:
    void copyLibFromState(sol::lib lib, const LibSymbolsRules &rules);
    ...
};

void LuaSandbox::copyLibFromState(sol::lib lib, const LibSymbolsRules &rules)
{
    // Определяемся с именем таблицы, где обитает запрошенная библиотека.
    const auto libLookupName = lua::libLookupName(lib);
    if (libLookupName.empty()) {
        return;
    }
    // Копировать будем отсюда,
    const sol::table src = runtime->state[libLookupName];

    // проверив, на всякий случай, что таблица таки существует.
    if (!src.valid()) {
        return;
    }

    // Функции из 'base' заливаются прямо в '_G', который у нас уже есть,
    // для остальных же библиотек придётся создать свои таблицы для копирования.
    if (lib != sol::lib::base) {
        sandbox[libLookupName] = sol::table(runtime->state, sol::create);
    }
    // Сюда.
    sol::table dst = sandbox[libLookupName];

    // Ну и, собственно, то, к чему мы так долго и тернисто шли — заливаем в песочницу,
    if (rules.allowedAllExceptRestricted) {
        // копируя вообще всё содержимое поэлементно,
        for (const auto &[name, object] : src) {
            dst[name] = object;
        }
        // и удаляя запрещёнку.
        for (const auto &name : rules.restricted) {
            dst[name] = sol::nil;
        }
    } else { // Ну или, в случае белого списка,
        // просто грузим только разрешённое.
        for (const auto &name : rules.allowed) {
            dst[name] = src[name];
        }
    }
}

// И чуть не забытый хелпер
namespace lua
{
    // для определения имени таблицы — местоположения библиотеки внутри Lua-стейта.
    constexpr auto libLookupName(sol::lib lib) -> std::string_view
    {
        // Функции из `base` сидят прямо в "корне" — '_G', в отличие от остальных библиотек.
        return (lib == sol::lib::base) ? "_G" : lua::libName(lib).value_or("");
    }
}  // namespace lua
```

И завершаем картину с библиотеками последними штрихами — интерфейс для их загрузки:

```cpp
// С++ — очень элегантный и лаконичный язык, вы только посмотрите, как изящно и непринуждённо
// он позволяет выразить синоним для "Какой-нибудь итерируемый контейнер с sol::lib внутри"
template <typename T>
concept SolLibContainer =
    std::ranges::range<T>
    && std::same_as<std::ranges::range_value_t<T>, sol::lib>;

// Благодаря чему мы сможем почти из любого контейнера грузить библиотеки сразу пачкой.
void LuaSandbox::loadLibs(const SolLibContainer auto &libs)
{
    for (const auto &lib : libs) {
        loadLib(lib);
    }
}

// Ну или по одной.
bool LuaSandbox::loadLib(sol::lib lib)
{
    const auto rules = checkRulesFor(lib); // Для неё правила есть вообще?
    if (!rules) {
        return false;
    }
    // Запрос на загрузку библиотеки в Lua-стейт.
    // Нам же нужно её откуда-то в песочницу подтягивать
    runtime->require(lib);

    copyLibFromState(lib, *rules);
    loadedLibs.insert(lib); // Учёт загруженных библиотек

    return true;
}

// Просто проверка на наличие правил для конкретной библиотеки
auto LuaSandbox::checkRulesFor(sol::lib lib)
    -> opt_cref<LibSymbolsRules>
{
    if (const auto it = libsSandboxingRules.find(lib); it =! libsSandboxingRules.end()) {
        return it->second;
    }
    return std::nullopt;
}

class LuaSandbox
{
    ...
public:
    void loadLibs(const SolLibContainer auto &libs);
    bool loadLib(sol::lib lib);

private:
    auto LuaSandbox::checkRulesFor(sol::lib lib)
        -> opt_cref<LibSymbolsRules>

    std::set<sol::lib> loadedLibs;
    ...
};
```

Здесь может несколько смутить возвращаемый тип `opt_cref<LibSymbolsRules>` для `checkRulesFor`, но это просто константный `std::optional` для `&`ссылок, который в 20 стандарт C++ ещё не завезли.

<details>
<summary> Реализация, если интересно. [развернуть]</summary>

```cpp
template <typename T>
class optional_ref
{
public:
    optional_ref() = default;
    optional_ref(std::nullopt_t) : ref(std::nullopt) {}
    optional_ref(T &value) : ref(value) {}

    explicit operator bool() const noexcept { return has_value(); }

    T &operator*() noexcept { return ref->get(); }
    const T &operator*() const noexcept { return ref->get(); }

    T *operator->() noexcept { return std::addressof(**this); }
    const T *operator->() const noexcept { return std::addressof(**this); }

    bool operator==(std::nullopt_t) const noexcept { return !has_value(); }
    bool operator!=(std::nullopt_t) const noexcept { return has_value(); }

    bool has_value() const noexcept { return ref.has_value(); }

    void reset() noexcept { ref.reset(); }

private:
    std::optional<std::reference_wrapper<T>> ref;
};

template <typename T>
using opt_ref = optional_ref<T>;

template <typename T>
using opt_cref = optional_ref<const T>;
```

</details>

---

## Все животные равны, но некоторые равнее.

Вспоминаем про нашу паранойю и позволим создавать песочницы только по заранее заданным шаблонам, ограничивающим список загружаемых библиотек.

Отдельно выделим шаблон `Custom`, для которого, мало того, что весь список библиотек доступен, так ещё и позволяем загружать их по мере необходимости, а не в момент создания песочницы.

```cpp
class LuaSandbox
{
public:
    enum class Presets { Core, Minimal, Complete, Custom };

    // Чуть доработаем наш конструктор
    // Чтобы без указания шаблона нельзя было создать песочницу
    explicit LuaSandbox(LuaRuntime &state, Presets preset)
        : lua(state),
          preset(preset)
    {...}

    // Ad-hoc загрузка библиотек для его величества Presets::Custom
    bool LuaSandbox::require(sol::lib lib)
    {
        if (preset == Presets::Custom) {
            return loadLib(lib);
        }
        return false;
    }
    ...

private:
    ...
    Presets preset{Presets::Core};

    using SandboxPresets = std::map<Presets, Libs>;
    inline static const SandboxPresets sandboxPresets{
        {Presets::Core, {}},
        {Presets::Minimal,
            {sol::lib::base,
             sol::lib::table}},
        {Presets::Complete,
            {sol::lib::base,
             sol::lib::coroutine,
             sol::lib::math,
             sol::lib::os,
             sol::lib::string,
             sol::lib::table}},
        {Presets::Custom, {}}
    };
};

// Добавим в reset() загрузку библиотек после сброса.
// И, т.к. он у нас несколько распух — вынесем в cpp-файл.
void LuaSandbox::reset(bool doCollectGrbg /* = false */)
{
    sandbox = sol::environment(lua->state, sol::create);
    sandbox["_G"] = sandbox;

    if (loadedLibs.empty()) {
        // Для конструктора используем список из пресета.
        loadLibs(sandboxPresets.at(preset));
    } else {
        // Если же инкарнация уже не первая, то грузим всё, что было в прошлой жизни.
        loadLibs(loadedLibs);
    }
    // Принудительная уборка мусора, в случае необходимости
    if (doCollectGrbg) {
        lua->state.collect_garbage();
    }
}
```

С основным, вроде, разобрались. Что у нас там дальше по списку?

<a id="scripts-anchor"></a>

## Разделяй и властвуй

Возможность запуска файлов со скриптами из самих скриптов.

В Lua это осуществляется двумя путями: через `loadfile`/`dofile` или `require`. Первые два живут в библиотеке `base`, последний — в `package`. Напомню, что ни одну из этих функций мы в песочницу не грузим, а родной `require`, так и вовсе со всей библиотекой игнорируем по соображениям безопасности. Но прежде чем делать свою реализацию, кратко пробежимся по ожидаемому от них поведению.

`loadfile` просто загружает указанный файл, компилирует его в байткод и возвращает как функцию, но не запускает на выполнение. Либо, в случае возникновения, возвращает ошибку _(если быть совсем точным, то сразу два значения: nil вместо функции и ошибку)_:

```lua
-- script.lua
scriptLoaded = true
```

```lua
scriptLoaded = nil

local fn, err = loadfile("script.lua")
if not fn then 
    print(err)
else
    print(scriptLoaded) -- > nil
    fn()
    print(scriptLoaded) -- > true
end
```

`dofile` же, и загружает _(через тот же самый 'loadfile')_, и запускает. А возвращает результат запущенной функции. В случае же возникновения ошибки, не возвращает ничего и бросает Lua-ошибку _(исключение, если хотите)_.

```lua
function dofile(filename)
    local fn, err = loadfile(filename)
    if not fn then
        error(err, 2)
    end
    return fn()
end
```

Эта ошибка, если не будет отловлена, например, через тот же `pcall`, приведёт к остановке программы. Благо, отлов реализовать довольно просто:

```lua
-- script.lua
return "One Ring to rule them all..."
```

```lua
local ok, res = pcall(dofile, "script.lua")
if not ok then
    print("error:", res) -- в res pcall поеместит сообщение об ошибке
end
print(res) -- > One Ring to rule them all...
```

Если же скрипт возвращает несколько значений, то нам нужно просто добавить количество переменных в соответствии с ожидаемым количеством результатов.

```lua
local ok, res1, res1, res3 = pcall(dofile, "script.lua")
```

Ошибка, в данном случае, будет помещена в `res1`.

И вот здесь нам нужно будет определиться — хотим мы отлавливать ошибки на стороне C++ или всё-таки Lua? Потому что от этого напрямую зависит семантика вызова — что именно будет сидеть в возвращаемом значении в случае ошибки, и ожидать ли Lua-коду её расшифровку _(если мы обернём вызов в pcall)_.

Но есть один нюанс. Дело в том, что для того, чтобы `pcall` смог поймать ошибку, мы должны вызвать её при помощи C API'шных функций `lua_error`/`luaL_error`, которые, в свою очередь, используют механизм `longjump` для переброса на тот самый вызов `pcall`. При этом происходит перепрыгивание через C++ кадры стека, и деструкторы C++ объектов на этом пути не вызываются. RAII и `lua_error`/`luaL_error` — не самые хорошие соседи.

Поэтому в целях данной статьи предлагаю остановиться на упрощённом варианте — отлавливать на стороне C++ и вообще ничего не возвращать в случае ошибки, плюс добавим ещё одну реализацию — `safe_dofile` с семантикой вызова аналогичной вызову через `pcall`, то есть:

```lua
local ok, res1, res2, res3 = safe_dofile("script.lua")
if not ok then
    print ("Error:", res1)
end
```

Так, с этими двумя, вроде, разобрались. Остался `require`.

А вот `requre` — это механизм Lua для загрузки модулей. Причём в качестве модулей могут выступать, помимо, собственно, скриптов `.lua`, файлы с уже скомпилированным Lua-байткодом _(в данном аспекте, кстати, `dofile` от него тоже не отстаёт)_, и библиотеки: начиная от стандартных Lua-библиотек _(о которых мы говорили выше)_, до обычных динамических C-библиотек _(ну, те, которые `.so/.dll/.dylib`)_. И это всё прямо из коробки. А если ещё добавить свои загрузчики, то проглотит вообще любой формат: будь то JSON, архив или бинарный код. _Вот уж где нашим юным натуралистам действительно было бы где разгуляться._

Кроме того, у `require` есть пара ключевых отличий от `dofile`, на которых придётся остановиться чуть подробнее, так как они важны для нашей реализации:

- Для того чтобы загрузить модуль, нам не нужно знать, где именно тот сидит в файловой системе — достаточно просто указать имя модуля, и `require` сам полезет его искать. И даже больше: `require` в принципе не сможет корректно обработать в качестве своего аргумента имя модуля с явным указанием пути к нему. А вот для `dofile` пути нужно указывать явно:

  | | | |
  |-|-|-|
  |`dofile("path/to/our/modules/rocket_science.lua")`| vs | `require("rocket_science")`|
  | | | |
  
  Ищет он, конечно, не по всей файловой системе, а только в заранее заданных путях, но механизм защиты переменной, содержащей разрешённые пути отсутствует напрочь — это одна из причин, почему мы не используем родной `require` предоставляемый Lua.

  На отсутствие расширения в имени файла во втором варианте внимание же тоже обратили, да? Это не ошибка — это ещё одна особенность, которую нужно учитывать.

- `require` не просто загружает файл, он задействует механизм кеширования уже подтянутых модулей и при повторном запросе просто подсовывает их из кеша. В нашем случае мы пойдём на упрощение и не будем реализовывать этот функционал, т.к. нам нужен хотрелоад _(перезагрузка модулей в случае их изменения на диске)_, и мы допускаем, что модули могут иметь одинаковые имена, но жить в разных директориях — например, у разных модов могут быть свои реализации.

Итого в сухом остатке по `require` имеем:
1. Скрипты грузить может, но нет возможности явно указать путь к файлу — вычёркиваем, `dofile` для этого лучше подходит.
2. Кеширование для нас не актуально — вычёркиваем.
3. А вот загрузку библиотек, пожалуй, оставим. Но ограничим только стандартными Lua-библиотеками — у нас как раз `Presets::Custom` предполагает такую возможность.

Запуск сторонних скриптов же целиком и полностью возложим на `dofile`.

## Path (2000) by Apocaliptica

Теперь нюансы, касающиеся самих путей.

Первое: `dofile` принимает как абсолютные, так и относительные пути. Причём, если с абсолютными всё понятно — ну это те, что `C:\Windows\System32` и `/opt/dwarffortress` — т.е. полные и однозначные. То с относительными — которые `../../.ssh` и `..\Downloads` — сложнее, так как в Lua они интерпретируются не относительно директории текущего скрипта (в котором `dofile` вызывается), а относительно текущего рабочего каталога **процесса**.

Поэтому, если предполагается хоть какая-то иерархическая организация файлов скриптов, то нам придётся для каждого вызываемого скрипта указывать полный путь к нему _(ну, не вручную в самом скрипте конечно, но определённую толику геморроя, связанного с подкапотными преобразованиями относительный -> абсолютный нам это добавит)_. Плюс, это позволит прикрыть лазейку с обходом ограничений путём подмены рабочего каталога самого процесса.

Следовательно, для песочниц нам нужно задать:
- Список разрешённых путей, откуда позволено скрипты запускать.
- Корневую директорию, от которой будут интерпретироваться относительные пути. Если же она не задана, то вообще их запрещаем и работаем только с абсолютными.

С теорией закончили, переходим к водным процедурам — начнём с добавления поддержки путей:

```cpp
namespace fs = std::filesystem;

class LuaSandbox
{
public:
    ...
    using Paths = std::vector<fs::path>;

    // Дополняем конструктор:
    //
    // @root          Рабочая директория — отсюда рассчитываются относительные пути
    //                скриптов. Если не задана, то разрешаем только абсолютные.
    // @allowedPaths  Список разрешённых путей, а вот здесь допускаем как 
    //                относительные, так и абсолютные.
    explicit LuaSandbox(LuaRuntime &runtime,
                        Presets preset,
                        const fs::path &root = {},
                        const Paths &allowedPaths = {})
        : runtime(&runtime),
          preset(preset)
    {
        setPathsForScripts(root, allowedPaths);
        reset();
    }

    // Интерфейс для добавления пути к списку разрешённых. Сделаем его публичным,
    // чтобы была возможность добавлять не только на этапе создания объекта
    bool allowScriptPath(const fs::path &path);
    ...
private:
    // А через это инициализируем пути при создании песочницы
    void setPathsForScripts(const fs::path &root, const Paths &allowed);

    // Преобразует текст в путь в т.ч. с учётом базового (для относительных)
    auto toScriptPath(const std::string &fileName) -> fs::path;
    ...
private:
    // Храним как абсолютные, лексически нормализованные
    fs::path scriptsRoot{};     // Базовый путь
    Paths allowedScriptPaths{}; // Список разрешённых, преобразованных в абсолютные
    ...
};
```

```cpp
void LuaSandbox::setPathsForScripts(const fs::path &root, const Paths &allowed)
{
    scriptsRoot.clear();
    if (!root.empty() && root.is_absolute()) {
        scriptsRoot = fs_utils::normalize(root);
    }
    allowedScriptPaths.clear();
    for (const auto &path : allowed) {
        allowScriptPath(path);
    }
}

bool LuaSandbox::allowScriptPath(const fs::path &path)
{
    // Не добавляем относительные пути если базовый изначально не был задан
    if (path.empty()
        || (scriptsRoot.empty() && path.is_relative())) {
        return false;
    }
    // Абсолютные добавляем как есть,
    // относительные преобразовываем относительно базового
    const auto allow = path.is_relative() ? scriptsRoot / path : path;
    allowedScriptPaths.push_back(fs_utils::normalize(allow));
    return true;
}

auto LuaSandbox::toScriptPath(const std::string &fileName)
    -> fs::path
{
    auto scriptPath = fs::path(fileName);
    // Если путь относительный, то преобразовываем его относительно базового.
    // Если он задан. Если нет, то это не наша проблема — наверху разберутся.
    if (scriptPath.is_relative() && !scriptsRoot.empty()) {
        scriptPath = scriptsRoot / scriptPath;
    }
    return scriptPath.lexically_normal();
}
```

`fs_utils::normalize` в представленном коде — это ещё один хелпер, на сей раз уже для работы с путями. Точнее, `fs_utils` — это неймспейс с несколькими такими утилитами. В силу того, что они лишь косвенно связаны с обсуждаемой темой, подробно останавливаться на этом не будем.

<details>
<summary> Но если, вдруг, совсем интересно. [развернуть]</summary>

```cpp
namespace fs = std::filesystem;

// Опять же — изящно и непринуждённо объявляем синоним для "любой контейнер с путями"
template <typename T>
concept fsPaths =
    std::ranges::range<T>
    && std::same_as<std::remove_cvref_t<std::ranges::range_value_t<T>>, fs::path>;

namespace fs_utils
{
    inline auto normalize(const fs::path &path) -> fs::path
    {
        auto result = path.lexically_normal();
        if (result.native().ends_with(fs::path::preferred_separator)) {
            return result.parent_path();
        }
        return result;
    }

    // Проверяет, что path находится внутри root
    inline bool startsWith(const fs::path &path, const fs::path &root)
    {
        if (root.empty()) {
            return false;
        }
        // Да, здесь присуствует fs::absolute, который строит путь относительно рабочей 
        // дирректории *процесса* — ибо утилита универсальная и работать должна с обоими типами,
        // но в нашем случае это не страшно т.к. мы сюда передаём только абсолютные пути.
        const auto rootNorm = normalize(fs::absolute(root));
        const auto pathNorm = normalize(fs::absolute(path));
        const auto [rootEnd, _] = std::ranges::mismatch(rootNorm, pathNorm);
        return rootEnd == rootNorm.end();
    }

    // Проверяет, что path находится внутри одного из roots
    inline bool startsWith(const fs::path &path, const fsPaths auto &roots)
    {
        if (roots.empty()) {
            return false;
        }
        for (const auto &root : roots) {
            if (startsWith(path, root)) {
                return true;
            }
        }
        return false;
    }
} // namespace fs_utils
```
</details>

---

Теперь у нас есть всё необходимое для реализации проверки путей при попытке запуска скрипта.

## Собираем в кучу

Прежде чем начать пережёвывать файл со скриптом нам нужно проверить его:
- На наличие.
- На допустимость его пути.
- И на его содержимое. Точнее, на то, что он **не** содержит уже скомпилированный байткод, т.к. он позволяет обойти ограничения песочницы.

```cpp
auto LuaSandbox::checkIfAllowedToLoad(const fs::path &scriptFile)
    -> std::tuple<bool, std::string_view> // Статус и текст ошибки, если она есть
{
    if (!fs::exists(scriptFile)) {
        return {false, "Attempting to run a non-existent script"};
    }
    if (!isPathAllowed(scriptFile)) {
        return {false, "Attempting to run a script outside the allowed path"};
    }
    if (lua::isBytecode(scriptFile)) {
        return {false, "Attempting to run precompiled Lua bytecode"};
    }
    return {true, {}};
}
```

```cpp
class LuaSandbox
{
    ...
private:
    bool isPathAllowed(const fs::path &scriptFile);
    auto checkIfAllowedToLoad(const fs::path &scriptFile)
        -> std::tuple<bool, std::string_view>;
    ...
};
```

С `fs::exists` всё понятно — функция стандартная, проверяет существование файла или самой директории.

С проверкой допустимости пути тоже всё довольно просто:

```cpp
bool LuaSandbox::isPathAllowed(const fs::path &scriptFile)
{
    if (scriptFile.empty()) {
        return false;
    }
    if (scriptFile.is_relative()) {
        if (scriptsRoot.empty()) {  // Проверяем, что можем преобразовать к абсолютному
            return false;
        }
        // Важно: в fs_utils::startsWith мы должны передавать асолютный путь,
        // иначе она там его автоматом интерпретирует относительно рабочей директории процесса
        return fs_utils::startsWith(scriptsRoot / scriptFile, allowedScriptPaths);
    }
    return fs_utils::startsWith(scriptFile, allowedScriptPaths);
}
```

А вот с проверкой на байт-код всё не так прозаично. Хотя...

Файлы, содержащие скомпилированный байт-код, начинаются со специальной сигнатуры `<esc>Lua`, где `<esc>` - это `27` в десятичной, или `033` в восьмеричной системе счисления, в которой она и объявлена в `lua.h`:

```cpp
#define	LUA_SIGNATURE	"\033Lua"
```

Поэтому просто проверяем первые 4 байта файла на соответствие ей.

```cpp
namespace lua
{
    bool isBytecode(const fs::path &file)
    {
        constexpr auto signature = std::string_view(LUA_SIGNATURE);

        auto ifs = std::ifstream(file, std::ios::binary);
        if (!ifs) {
            return false;
        }
        auto header = std::array<char, signature.size()>{};
        ifs.read(header.data(), header.size());
        if (ifs.gcount() < static_cast<std::streamsize>(header.size())) {
            return false;
        }
        return ranges::equal(header, signature);
    }
} // namespace lua
```

## loadfile

Напомню контракт вызова — стандартная (nil, error) идиома:

```lua
result, error = loadfile("filename.lua")
if not result then
    -- тогда error содержит ошибку
end
```

В C++ у нас для таких случаев есть `pair` или `tuple`. Пускай будет `tuple`.

```cpp
using ResultOrErrorMsg = std::tuple<sol::object, sol::object>;
```

Осталось обеспечить, чтобы можно было напрямую принимать аргументы из Lua скриптов — а там это реализуется через универсальный `sol::stack_object` — и у нас наконец-то вырисовывается замена для `loadfile`.

```cpp
auto LuaSandbox::loadfileReplace(sol::stack_object fileName)
    -> ResultOrErrorMsg
{
    // Введём просто чтобы сократить количество писанины 
    auto lua = sol::state_view(runtime->state.lua_state()); 

    // Используется для формирования результата с ошибкой
    auto makeError = [&](std::string_view errMsg) -> ResultOrErrorMsg {
        return {sol::nil, sol::make_object(lua, errMsg)};
    };

    // На всякий случай
    if (!fileName.is<std::string>()) {
        return makeError("Bad argument #1 to 'loadfile' (string expected)");
    }

    // sol::stack_object -> fs::path
    const auto filePath = toScriptPath(fileName.as<std::string>());

    // Проверяем уже сам файл на допустимость
    const auto &[isFileOk, fileErrMsg] = checkIfAllowedToLoad(filePath);
    if (!isFileOk) {
        return makeError(fileErrMsg);
    }

    // А это, собственно, родной Lua loadfile
    auto loadResult = lua.load_file(filePath.string(), sol::load_mode::text);
    if (!loadResult.valid()) {
        sol::error err = loadResult;
        return makeError(err.what());
    }
    // "Вытягиваем" из полученного loadResult чанк-функцию
    auto chunk = sol::protected_function(loadResult);
    sandbox.set_on(chunk); // и "опесочиваем" его, подменяя окружение
                           // Напомню: sandbox здесь — это объект sol::environment

    return { sol::make_object(lua, chunk), sol::nil };
}
```

## safe_dofile

_*Который с контрактом `(ok, results... = safe_dofile())`_

А вот для возврата переменного количества значений в `sol2` есть `sol::variadic_results`, который, фактически, представляет собой не что иное, как просто вектор объектов `sol::object`.

```cpp
auto LuaSandbox::dofileSafe(sol::stack_object fileName)
    -> sol::variadic_results
{
    // Опять же, сокращаем количество писанины 
    auto lua = sol::state_view(runtime->state.lua_state());

    auto result = sol::variadic_results {}; // Результат выполнения скрипта

    // Лямбда для формирования "ошибочного" результата, содержащего текст ошибки.
    auto makeError = [&](const std::string &msgError) {
        result.push_back (sol::make_object(lua, false));
        result.push_back(sol::make_object(lua, msgError));
        return result;
    };

    // Загружаем файл скрипта.
    // Все проверки пути и самого файла мы там уже реализовали.
    auto [chunk, error] = loadfileReplace(fileName);
    if (!chunk.valid()) {
        const auto msgError = std::format(R"(Unable to load script "{}". Error: "{}")",
                                          fileName.as<std::string>(),
                                          error.as<std::string>());
        return makeError(msgError);
    }
    // Т.к. на выходе из loadfile chank у нас обёрнут в sol::object, нам нужно
    // явно указать, что это функция, прежде чем вызвать её на выполнение.
    auto fn = chunk.as<sol::protected_function>(); 
    
    // Запускаем и проверяем уже на наличие ошибки выполнения самого скрипта.
    // sol::protected_function_result, возвращаемый fn(), даёт нам такую информацию.
    auto scriptResult = fn(); 
    if (!scriptResult.valid()) {
        sol::error err = scriptResult;
        const auto msgError = std::format(R"(Unable to execute script "{}". Error: "{}")",
                                          fileName.as<std::string>(),
                                          err.what());
        return makeError(msgError);
    }

    result.push_back(sol::make_object(lua, true)); // Пушим первый объект — статус выполнения
    // И вытягиваем все значения из результата выполнения запрошенного скрипта
    for (auto &&value : scriptResult) {
        result.push_back(value); 
    }
    return result;
}
```

## dofile

В документации на `sol2` форграундом по бэкграунду написано, что предпочитаемый способ запуска скриптов — через `sol::state::script()` и `sol::state::script_file()` _(ну или их safe - версии)_. Предпочитаемый до тех пор, пока вы явно не захотите странного [_(правда в терминах документации это звучало как: полного контроля над загрузкой и выполнением кода)_]. Странного мы уже хотели — `loadfileReplace` и `dofileSafe` реализованы как раз через это. Обычный же `dofile` сделаем по заветам RTFM.

По большому счёту `script_file()` - это не что иное, как уже реализованная на стороне `sol2` обёртка над `loadfile` с последующим запуском скомпилированной им функции. А safe-версия просто добавляет контроль ошибок через `pcall`.

И тут вспоминаем, про *уже* имеющийся у нас `runFile`, который запускает запрошенный файл со скриптом.
```cpp
auto LuaSandbox::runFile(const fs::path &scriptFile)
    -> sol::protected_function_result
{
    return runtime->state.safe_script_file(scriptFile, sandbox); // Прям по канону )
}
```

Да, пока не содержит вообще никаких проверок, но чуть доработать напильником и замена для `dofile` с ожидаемым поведением у нас в кармане.

Небольшое отступление _(давно не было, правда? Но это нам, действительно, сейчас понадобится - придётся ещё немного потерпеть)_ — пара слов о `sol::protected_function_result`, который мы здесь возвращаем.

В `sol2` есть два типа функций с довольно характерными названиями: `sol::unsafe_function` — дефолтный, и `sol::protected_function`.

Когда мы вызываем Lua-функцию через `sol::protected_function`, `sol2` перехватывает любые рантайм ошибки Lua и, вместо того чтобы позволить программе аварийно завершиться или передать ошибку в виде C++-исключения _(как бы он это сделал для `sol::unsafe_function`)_, оборачивает её в `sol::protected_function_result` и возвращает как результат выполнения функции. В случае же успешного завершения, в него заворачиваются все возвращаемые значения вызываемой функции _(да, их может быть несколько)_. Фактически, это такой аналог вызова через `pcall` в Lua.

`safe_script()` и `safe_script_file()`, кстати, тоже его возвращают.

```cpp
sol::state lua;

const auto script(R"(
    function divide(a, b)
        if b == 0 then 
            error("Are you kidding me?", 2)
        end
        return a / b
    end
    return divide
)");

auto divide = lua.safe_script(script); // sol::protected_function
if (!divide.valid()) {
    return;
}

auto result = divide(42, 0); // sol::protected_function_result
if (!result.valid()) {
    sol::error err = result;
    std::cerr << err.what() << '\n'; // -> "Are you kidding me?"
    // Обработка ошибки
    return
}
float quotient = result;
// Или так:
auto alsoQuotient = result.get<float>();
```

А, вот, чтобы сформировать его вручную надо немного заморочиться:
 1. В случае успешного выполнения функции поместить в стек — возвращаемый функцией Lua-объект, будь то значение, таблица, функция или `nil`;
 2. Или же, в случае ошибки, вместо результата пушим в стек соответствующее ей сообщение;
 3. И, наконец, создаём объект `sol::protected_function_result` с указанием статуса результата — валидный, который можно использовать дальше, или же — ошибка, которую нужно обработать. Здесь же указываем количество объектов, которое поместили в стек _(да, их может быть несколько, но в нашем случае используем только один)_, эта информация в т.ч. нужна деструктору `sol::protected_function_result` для того, чтобы подчистить стек за собой, но это уже нюансы реализации `sol2`, не будем углубляться.

Звучит многословно, но в коде выглядит более чем лаконично:

```cpp
namespace lua
{
    auto makeFnCallResult(sol::state &lua,
                          const auto &object,
                          sol::call_status callStatus = sol::call_status::ok)
        -> sol::protected_function_result
    {
        bool isResultValid = callStatus == sol::call_status::ok;
        sol::stack::push(lua, object);
        return sol::protected_function_result(lua, -1, isResultValid ? 1 : 0, 1, callStatus);
    }
} // namespace lua
```

Вот теперь мы можем дополнить `runFile` проверками на допустимость файла и возвращать ошибку, если их не проходим.

```cpp
auto LuaSandbox::runFile(const fs::path &scriptFile)
    -> sol::protected_function_result
{
    // Лямбда для формирования "ошибочного" результата, содержащего текст ошибки.
    auto error = [&](std::string_view msg) {
        const auto errMsg = std::format("{}: {}", msg, scriptFile.string());
        return lua::makeFnCallResult(runtime->state, errMsg, sol::call_status::file);
    };

    // Проверки на допустимость файла
    if (const auto [isFileOk, errMsg] = checkIfAllowedToLoad(scriptFile); !isFileOk) {
        return error(errMsg);
    }
    return runtime->state.safe_script_file(scriptFile, sandbox);
}
```

Осталось обернуть его для приёма аргументов напрямую из Lua скриптов _(помним же про `sol::stack_object`?)_. Ну и ошибки обрабатываем на стороне C++, т.к. Lua даже не знает о существовании `sol::protected_function_result`, который для него любезно распатронивает `sol2`. И, собственно, всё — замена для `dofile` у нас готова:

```cpp
auto LuaSandbox::dofileReplace(sol::stack_object fileName)
    -> sol::protected_function_result
{
    // Опять же, на всякий случай
    if (!fileName.is<std::string>()) {
        return {}; // ничего не возвращаем
    }
    // sol::stack_object -> fs::path
    const auto filePath = toScriptPath(fileName.as<std::string>());

    auto scriptResult = runFile(filePath);
    if (!scriptResult.valid()) {
        sol::error err = scriptResult;
        // Обработка ошибок
        // std::cout << err.what() << '\n'

        return {}; // ничего не возвращаем
    }
    return scriptResult;
}
```

## require

С заменой для `require` всё существенно проще: если запрашиваемый аргумент — имя стандартной Lua-библиотеки, то пробуем её загрузить. Контроль того, что можно загружать и для какого из пресетов `LuaSandbox::Presets`, у нас уже реализован. Так что, в случае успеха, возвращаем таблицу с загруженной библиотекой, иначе `nil` — все ошибки обрабатываем на стороне C++.

```cpp
auto LuaSandbox::requireReplace(sol::stack_object target)
    -> sol::object
{
    if (!target.is<std::string>()) {
        return sol::nil;
    }
    const auto possibleLibName = target.as<std::string>();
    const auto lib = lua::libByName(possibleLibName);
    if (!lib) { // Проверяем есть ли такая бибилиотека
        // std::format(R"(require("{}"): library not found.)", possibleLibName);
        return sol::nil;
    }
    if (!require(*lib)) { // Пробуем её загрузить
        // std::format(R"(require("{}"): library is forbidden.)", possibleLibName);
        return sol::nil;
    }
    const auto libLookupName = lua::libLookupName(*lib);
    return sandbox[libLookupName];
}
```

Наконец, объявляем:

```cpp
class LuaSandbox
{
public:
    using ResultOrErrorMsg = std::tuple<sol::object, sol::object>;
    ...
private:

    auto loadfileReplace(sol::stack_object fileName) -> ResultOrErrorMsg;
    auto dofileReplace(sol::stack_object fileName) -> sol::protected_function_result;
    auto dofileSafe(sol::stack_object fileName) -> sol::variadic_results;
    auto requireReplace(sol::stack_object target) -> sol::object;

    // Метод, которым будем регистрировать наши замены
    void loadSafeExternalScriptFilesRoutine()
    {
        sandbox.set_function("loadfile", &LuaSandbox::loadfileReplace, this);
        sandbox.set_function("dofile", &LuaSandbox::dofileReplace, this);
        sandbox.set_function("safe_dofile", &LuaSandbox::dofileSafe, this);
        sandbox.set_function("require", &LuaSandbox::requireReplace, this);
    }
    ...
};
```

И на этом с водными процедурами заканчиваем. Можно выдыхать.

Вот так — тихо и незаметно, на исходе второй части мы подобрались к тому, с чего начинаются все учебники )

<a id="hello-world-anchor"></a>

## Hello world!

Итак, `print`. В принципе, его можно было бы и родной оставить, но раз есть возможность перенаправить его выхлоп куда-нибудь помимо `stdout` то почему бы ею не воспользоваться?

Для сохранения логики работы оригинального `print` — а он мало того, что сам корректно конвертирует числа, так ещё и для таблиц и функций, полученных в качестве аргументов, даст строки вида `table: 0x12345` / `function: 0x...` — нам придётся задействовать стандартный `tostring` из `sol::lib::base`. Причём в саму песочницу его грузить не нужно — достаточно того, чтобы он присутствовал в Lua-стейте.

Ну и, естественно, добавим опцию изменения потока вывода.

```cpp
void LuaSandbox::printReplace(sol::variadic_args args)
{
    std::string result;
    for (auto &&arg : args) {
        result += lua::toString(arg);
        result += " "; // Родной print все аргументы разделяет пробелами.
    }
    if (!result.empty()) {
        result.pop_back(); // Удаляем лишний пробел в конце.
    }
    *printOutStrm << "[lua sandbox]:> " << result << "\n";
}
```

```cpp
namespace lua
{
    auto toString(const sol::object &obj) -> std::string
    {
        sol::state_view lua(obj.lua_state());
        if (!lua["tostring"].valid()) {
            return {};
        }
        return lua["tostring"](obj).get<std::string>();
    }
} // namespace lua
```

Остаётся только доработать определение класса — добавляем в конструктор песочницы аргумент с потоком вывода, объявляем нашу замену для `print` и добавляем метод, осуществляющий его подмену.

```cpp
class LuaSandbox
{
public:
    ...
    explicit LuaSandbox(LuaRuntime &runtime,
                        Presets preset,
                        const fs::path &root = {},
                        const Paths &allowedPaths = {},
                        std::ostream &printOutStrm = std::cout)  // По умолчанию оставляем `stdout`
        : runtime(&runtime),
          preset(preset),
          printOutStrm(&printOutStrm)
    {...}

    ...

private:
    void printReplace(sol::variadic_args args);

    void loadSafePrint()
    {
        // В Lua-стейт должна быть загружена библиотека base, чтобы tostring работал.
        // Обращаю внимание: в стейт. В самой песочнице эта библиотека может быть
        // вообще не загружена, но print работать будет.        
        runtime->require(sol::lib::base);
        sandbox.set_function("print", &LuaSandbox::printReplace, this);
    }
    ...

    std::ostream *printOutStrm;
};
```

## «Ага, б...!» — сказали суровые сибирские лесорубы

Ну что, в качестве промежуточного итога давайте теперь попробуем нашкодить?

```cpp
// Cpp
namespace fs = std::filesystem;

const auto wrkDir = fs::current_path(); // Пускай будет рабочий каталог процесса
const auto allowedDirs = LuaSandbox::Paths{wrkDir / "scripts"};

auto lua = LuaRuntime {};
auto sandbox = LuaSandbox(lua,
                          LuaSandbox::Presets::Core, // Запрещаем вообще все либы
                          wrkDir, // Базовый каталог для относительных путей
                          allowedDirs); // Разрешаем скрипты только отсюда
```

```lua
-- try_1.lua
-- ../try_1.lua
-- scripts/try_1.lua

-- print есть?
if print then
    -- что, и работает?
    print("Knock-knock-knok... ") -- > Knock-knock-knok... 
else 
    return "не, не в этот раз"
end

-- ok, print есть, значит base загружена?
if not ipairs or not pcall then
    -- А вот хрен там - не загружена

    if require then -- а require есть?
        -- есть! пробуем загрузить base
        local res = require("base")
        
        if not res then 
            -- литовский праздник
            return "Обломайтэс"
        end
    end
end
return "bingo!"
```

```cpp
// Cpp

// Пробуем выполнить скрипт
assert(fs::exist("script/try.lua") == false); // не существующий
auto result = sandbox.runFile("script/try.lua"); // но в пределах разрешённого пути
assert(result.valid() == false);

assert(fs::exist("try_1.lua") == false); // существующий
auto result = sandbox.runFile("try_1.lua"); // но вне "scripts"
assert(result.valid() == false);

assert(fs::exist("../try_1.lua") == false); // существующий
result = sandbox.runFile("../try_1.lua"); // но за пределами рабочего каталога
assert(result.valid() == false);

result = sandbox.runFile("scripts/try_1.lua");
assert(result.valid() == true); // ага, получилось

assert(result.get<std::string>() == "Обломайтэс"); // но библиотеку не может загрузить

// Ладно, а так?
sandbox = LuaSandbox(lua,
                     LuaSandbox::Presets::Custom, // Разрешаем ad-hoc подгрузку либ
                     wrkDir,
                     allowedDirs);

result = sandbox.runFile("scripts/try_1.lua");
assert(result.get<std::string>() == "bingo!"); // а так загрузил

// Ок, пробуем запрещёнку
```

```lua
-- scripts/try_2.lua

-- Чего мелочиться, давайте ФС пощупаем
-- Проверка на дурака - вдруг уже есть?
if io then
    return "io.open('~/.ssh/config', 'r')"
end
-- ну да, конечно...

-- пытаемся загрузить
io = require("io")
if io then
    return "io.open('~/.ssh/id_ed25519', 'r')"
end

-- ладно, тогда что-нибудь не сильно запрещённое
os = require("os")
-- проверям те, что гарантированно разрешены
if not os.time or not os.clock or not os.difftime then
    return "неожиданно..."
end

-- о, загрузилась
if os.execute then
    return "os.execute('echo rm -rf ~/')"
end
-- но не вся
return "хрен там"
```
```cpp
// Cpp
result = sandbox.runFile("scripts/try_2.lua");
assert(result.get<std::string>() == "хрен там"); // опять мимо

// Ну что, остались только скрипты из Lua
```

```lua
-- downloads/pandoras_box.lua
-- scripts/pandoras_box.lua

require(table)

local box = {}

function box:open()
    -- Тут интрига, ниже раскрою
end

function box.punishment(count)
    -- интрига
end

function box.mobius()
    -- интрига
end

function box:init()
    self.open()
end

return box
```

```lua
-- scripts/script_loader.lua

-- пробуем несуществующий файл
local fn, err = loadfile("scripts/pandoras_chest.lua")
if fn then 
    return "It's a miracle"
end

-- существующий, но вне допустимого пути
fn, err = loadfile("downloads/pandoras_box.lua")
if fn then 
    return "Oops..."
end

-- ладно, хватит издеваться - загружаем нормальный
fn, err = loadfile("scripts/pandoras_box.lua")
if not fn then
    return "Вот это поворот!"
end

-- отлично - загружается, для разнообразия запустим через safe_dofile
local ok, res = safe_dofile("scripts/pandoras_box.lua")
if not ok or (not res and not res.init) then
    return "Oops!... I did it again"
end

harmless = res -- и помещаем в глобальную область видимости

return "Bomb has been planted"
```

```cpp
// Cpp

// И проверяем на вшивость
result = sandbox.runFile("scripts/script_loader.lua");
assert(result.get<std::string>() == "Bomb has been planted");

// Поздравляю — Mischief managed

sandbox.run("harmless:init()"); // kaboom baby!
```

Потому что:

```lua
-- Интрига
function box:open()
    -- этот лангоньер сжирает всю память
    for i = 1, 1000000 do
        self.punishment(1000000)
    end
    -- а этим мы вешаем систему
    self.mobius()
end

function box.punishment(count)
    chalkboard = chalkboard or {}
    for iter = 1, count do
        table.insert(chalkboard, "I will not waste chalk" .. ", ")
    end
end

function mobius()
    while true do end
end
```

<a id="allocators-anchor"></a>

## Не трогай, это на новый год

Прежде чем переходить к ограничению потребляемой памяти, сначала разберёмся, как, собственно, в Lua реализована работа с ней.

Каждый раз, когда Lua требуется выделить, перераспределить или освободить память, происходит вызов универсального аллокатора.

```lua
-- Создаём новую таблицу?
supply = {'Sugar', 'Water'} -- Lua запрашивает новую память через аллокатор

-- Добавляем элемент в уже существующую?
table.insert(supply, 'Yeast') -- Lua через тот же аллокатор изменяет размер

-- Загружаем новые функции?
dofile("booze_routine.lua") -- Снова дёргаеся аллокатор - выделяет под них память.

local shot = getBooze(supply)

shot.coolingTo(6)

-- Удаляем объект?
drink(shot) -- Тоже через аллокатор, но отложенно, а не в момент удаления.
            -- Сборщик мусора вызовет его когда посчитает нужным.
            -- Сам же объект в Lua считается удалённым сразу.
```

```Lua
-- booze_routine.lua
function getBooze(rawMaterials)

    local barrel = getBarrel();

    for i = #rawMaterials,1,-1 do
        local item = table.remove(rawMaterials)
        barrel.put(item)
    end

    barrel.warmUpTo(23)

    while not barrel.isReady() do
        barrel.proceed()
    end
    return distilate(barrel)
end

function drink(what)
    what = nil
end
```

Если прям совсем упростить, то весь требуемый функционал — выделение, удаление и изменение размера уже выделенного блока — реализуется на коленке через `realloc` и `free`:

```cpp
void *luaAlloc(void *ptr, size_t newSize)
{
    if (newSize == 0) {
        free(ptr);
        return NULL;
    }
    return realloc(ptr, newSize);
}
```

Собственно, стандартный именно так и выглядит. Ну, за исключением пары нюансов, о которых чуть позже.

А теперь самое интересное: Lua позволяет подменить свой стандартный аллокатор пользовательским и гарантирует, что абсолютно все запросы памяти будут идти именно через него. То есть механизм у нас есть: перехватываем контроль за выделением памяти, ведём её учёт и, в случае превышения лимитов, просто не даём лишнего.

Более того, Lua нам существенно упрощает жизнь в плане реализации учёта, так как на самом деле в аллокатор он передаёт ещё два очень полезных для нас параметра:

```cpp
void *luaAlloc(void *ud, void *ptr, size_t currSize, size_t newSize);
```

`ud` — указатель на блок пользовательских данных и `currSize` — текущий размер блока памяти, на который указывает `*ptr`.

Причём, если с первым всё прозаично — мы можем указать Lua на любую структуру с произвольным набором переменных, которую хотим видеть в качестве аргумента в аллокаторе — в нашем случае она будет хранить его состояние. То с текущим размером блока чуть сложнее.

Дело в том, что он, как бы это сказать... он — не всегда размер. Если `*ptr` ссылается на уже выделенную память, то это размер. А вот если Lua запрашивает выделение нового блока памяти (`*ptr == NULL`), то он может принимать другие значения: например, код типа объекта, который Lua сейчас пытается создать, ну так, чисто в качестве подсказки. Имейте в виду — это поведение завезли только для Lua 5.2+. Можно смело пользоваться, если пишете навороченный аллокатор, оптимизирующий выделение памяти.

Всё, что нам остаётся — обеспечить такое поведение нашего аллокатора, которое удовлетворяет ожиданиям Lua:

| `*ptr` | `currSize` | `newSize` | ожидаемое поведение |
|--------|------------|-----------|---------------------|
| `NULL` | 0 либо код типа | > 0 | Выделяем новый блок запрошенного размера. Возвращаем указатель на него, либо `NULL` если выделить не удалось. |
| `!NULL`| > 0 | 0   | Освобождаем память, на которую ссылается `ptr`. Возвращаем `NULL`. |
| `!NULL`| > 0 | > 0 | Прикидываемся `realloc`'ом: изменяем размер блока, на который указывает `*ptr`, возвращаем указатель в случае успеха или `NULL`, если увеличить не удалось. |

Сама же подмена осуществляется в момент создания Lua-стейта:

```cpp
void *limitedAlloc(void *ud, void *ptr, size_t currSize, size_t newSize);

constexpr size_t cLualMemoryLimit = 1 * 1024 * 1024; // 1 Mb

struct LuaAllocatorState
{
    size_t used {};
    size_t limit {cLualMemoryLimit};
} allocState;

sol::state lua(sol::default_at_panic, limitedAlloc, &allocState);

```

Насчёт первого аргумента — `sol::default_at_panic` — пока не заморачиваемся, это дефолтный `sol`'овский обработчик ошибок типа "всё пропало". Просто в конструкторе он идёт первым, и мы вынуждены его указать явно _(можно также своим подменить, но сейчас не актуально)_, чтобы была возможность задать последние два аргумента.

Ну и нужно следить за тем, чтобы жизненный цикл `allocState` был больше, чем у самого `lua::state`, т.к. при удалении последнего Lua активно использует наш аллокатор для того, чтобы прибить всё, что успел навыделять для себя.

Да, немаловажный момент: обращаю внимание на то, что аллокатор именно на Lua-стейт ставится. То есть он у нас будет общий на все песочницы, которые крутятся на этом стейте. Следовательно, и лимит на выделяемый объём памяти будет общий для всех них — это нужно учитывать при его определении. Если же прям жёсткого контроля захочется, то тогда придётся работать по схеме один рантайм — одна песочница.

На этом, пожалуй, хватит теории.

Поехали:

```cpp
namespace lua::memory
{
    constexpr size_t c1MB = 1L * 1024 * 1024;
    constexpr size_t cDefaultMemLimit = c1MB;

    struct LimitedAllocatorState
    {
        size_t used {};
        size_t limit {cDefaultMemLimit};

        // Аварийные флаги
        bool limitReached {false};
        bool overflow {false};

        bool isLimitEnabled() { return limit > 0; }
        void disableLimit() { limit = 0; }
        void resetErrorFlags() { limitReached = overflow = false; }        
    };

    void *limitedAlloc(void *ud, void *ptr, size_t currSize, size_t newSize)
    {
        auto *allocState = static_cast<LimitedAllocatorState*>(ud);

        // Отказываемся работать без указателя на состояние
        if (allocState == nullptr) {
            assert(allocState != nullptr
                   && "Pointer to the allocator state must be provided.");
            return nullptr;
        }
        if (ptr == nullptr) {
            // Здесь обработка подсказок насчёт типа создаваемого объекта.
            // ...должна быть. Но в нашем случае не актуально — опускаем.
            // И обнуляем currSize для того,
            // чтобы дальше арифметика коректно работала.
            currSize = 0;
        }
        if (newSize == 0) {
            if (ptr != nullptr) {
                // Просто на всякий случай, чтобы не улететь ниже 0
                allocState->used -= (allocState->used >= currSize)
                                    ? currSize
                                    : allocState->used;
            }
            std::free(ptr);
            return nullptr;
        }
        // Опять же, чтобы не свалиться ниже 0 при дальнейших расчётах
        const size_t usedBase = (allocState->used >= currSize)
                                ? allocState->used - currSize
                                : 0;
        // Защита от переполнения
        if (newSize > (std::numeric_limits<size_t>::max() - usedBase)) {
            allocState->overflow = true;
            return nullptr;
        }
        
        const size_t newUsed = usedBase + newSize;

        // Проверяем, нет ли попытки откусить больше дозволенного
        if (allocState->isLimitEnabled() && newUsed > allocState->limit) {
            allocState->limitReached = true;
            return nullptr;
        }
        void *newPtr = std::realloc(ptr, newSize);
        if (newPtr != nullptr) {
            allocState->used = newUsed;
        }
        return newPtr;
    }
} // namespace lua::memory

```

Ну а подружить с `LuaRuntime` — это уже совсем тривиальная задача.

```cpp
class LuaRuntime
{
private:
    lua::memory::LimitedAllocatorState allocatorState;
    lua_Alloc allocatorFn{nullptr};

public:
    sol::state state; // state у нас уже был объявлен, но здесь я его намеренно
                      // указал ещё раз, чтобы подчеркнуть порядок объявления полей
                      // от которого зависит их время жизни:
                      // allocatorState должен быть объявлен раньше чем state,
                      // чтобы гарантировать работу аллокатора,
                      // на этапе удаления state.
    ...
public:
    // Добавляем ещё один конструктор в LuaRuntime,
    // и теперь можем создавать рантаймы с поддержкой лимитов на память
    LuaRuntime(size_t memoryLimit, lua_Alloc fn = lua::memory::limitedAlloc)
        : allocatorState({.limit = memoryLimit}),
          allocatorFn(fn),
          state(sol::default_at_panic, fn, &allocatorState)
    {}

    // Чтобы не возвращаться к этому вопросу позже —
    // сразу реализуем возможность сброса lua-стейта
    void reset()
    {
        if (allocatorState.isActivated()) {
            // Т.к. и для старого и для нового sol::state у нас один и тот же
            // allocatorState, причём сначала создастся новый и только потом будет
            // удалён старый, то в теории возможен выход за пределы установленного
            // лимита. Поэтому просто отключим лимит на время этих телодвижений.

            // Сохраняем для нового стейта
            const auto currentLimit = allocatorState.limit;
            allocatorState.disableLimit();

            state = sol::state(sol::default_at_panic, allocatorFn, &allocatorState);
            // К этому моменту allocatorState.used у нас сначала увеличился на
            // размер выделенной памяти для нового lua-стейта, а затем уменьшился
            // на весь объём памяти предыдущего.
            // Т.е. сейчас он у нас полностью соответствует новому.
            // Его вместе с размером лимита переносим в новый allocatorState,
            // а все остальные поля сбрасываем до дефолтных значений.
            allocatorState = {.used = allocatorState.used, .limit = currentLimit};
        } else {
            state = sol::state();
        }
    }

    bool hasAllocError()
    {
        return allocatorState.limitReached || allocatorState.overflow;
    }
    void resetAllocErrors() { allocatorState.resetErrorFlags(); }

    auto getAllocatorState()
        -> const lua::memory::LimitedAllocatorState &
    { 
        return allocatorState;
    }

    bool usesLimitedAllocator() { return allocatorFn != nullptr; }
 
    // Ну и механизм изменения лимита на лету — потом пригодится.
    bool LuaRuntime::setMemoryLimit(size_t limit)
    {
        if (allocatorState.isActivated()) {
            allocatorState.limit = limit;
        }
        return allocatorState.isActivated();
    }
    ...
};
```

Теперь Lua, получив вместо запрошенного куска памяти неожиданный `nullptr`, сгенерирует соответствующую ошибку. А стандартный способ их перехвата — это проверка результата выполнения скрипта:

```cpp
LuaRuntime lua(16'384); // 16 Kb
LuaSandbox sandbox(lua, LuaSandbox::Presets::Minimal);

// Здесь с тем же успехом мог быть вызов через sandbox.runFile()
auto result = sandbox.run(R"(
    chalkboard = {}
    while true do
        table.insert(chalkboard, "I will not waste chalk" .. ", ")
    end
)");

if (!result.valid()) {
    if (lua.hasAllocError()) {
        ...
        // Если нужно, можем прям детально до конкретного варианта ошибки докопаться:
        // auto allocatorState = lua.getAllocatorState();
        // if (allocatorState.limitReached) {...};
        // if (allocatorState.overflow) {...};
        lua.resetAllocErrors(); // И можно дальше работать
    } else { 
        // остальные виды рантайм ошибок
        sol::error error = result;
        std::cout << std::format("Script execution resulted in the following error: \"{}\"\n",
                                 error.what());
    }
}
```

Точнее — один из стандартных способов, но наиболее подходящий для нас, т.к. альтернатива — это исключения, которыми код `sol2` обмазан более чем достаточно, и в нашем случае их хотелось бы избежать _(ну геймдев же, ну) Ⓒ_. К счастью, `sol2` позволяет их запрещать явно.

Помните я в начале говорил о том, что для подключения Lua к нашему C++ проекту достаточно одного заголовочного файла? Я немного упростил. На самом деле нам придётся ещё задать несколько опций для конфигурации `sol2`, но на том этапе это была избыточная информация. Теперь можно )

```cpp
#define SOL_ALL_SAFETIES_ON 1   // Включает все доступные в sol2 механизмы безопасности,
                                // в т.ч. частично заменяет выброс исключений в случае 
                                // возникновения ошибок Lua на возврат самих ошибок
                                // в виде sol::protected_function_result.

#define SOL_NO_EXCEPTIONS 1     // Отключаем вообще все исключения внутри sol2
#define SOL_LUA_VERSION 501     // Явно указываем используемую версию Lua

#include <sol/sol.hpp> // И только потом подключаем сам заголовочный файл
```

Предлагаю на тему аллокаторов на этом закруглиться, а то мы так сейчас и до перехода на `mimalloc`/`jemalloc`/`tcmalloc` договоримся... Что, кстати, далеко не лишено смысла.

<a id="timeoutGuard-anchor"></a>

## "Я буду готова через 5 минут" `(с)`

Здесь, на самом деле, не так много вариантов. Наибанальнейшая мысль _[[признаюсь, весь цикл задумывался только для того, чтобы было куда вставить этот оборот]]_, которая первой приходит в голову — нам всего-то нужно периодически останавливать выполнение Lua-скрипта для проверки прошедшего времени. Если лимит не исчерпан — возвращаем управление в Lua до следующего прерывания, если же отпущенное время истекло — генерируем ошибку и в скрипт уже не возвращаемся. К сожалению, механизм, который позволяет всё это провернуть в Lua уже есть, и нам не придётся его рожать самостоятельно.

### Хуки

Lua позволяет указать ей произвольную C-функцию, которая будет вызываться при наступлении определённых событий.

```cpp
int lua_sethook(lua_State *L,
                lua_Hook func,  // Произвольная функция — обработчик прерывания
                int mask,       // Тип прерывания
                int count);     // и периодичность его срабатывания
```

Причём в нашем распоряжении на выбор аж четыре типа прерываний. Допустимые значения `mask`:

```cpp
LUA_MASKCALL  //  Срабатывает при каждом вызове функции (любой) интерпретатором Lua
LUA_MASKRET   //  При возврате из функций -- т.е. перед каждым return
LUA_MASKLINE  //  При переходе интерпретатора к выполнению новой строки кода
              //  и, барабанная дробь....
LUA_MASKCOUNT //  Каждый раз после выполнения определённого количества инструкций
```

Вот последний — как раз то, что доктор прописал. Так как, что бы мы там себе в скриптах не нашкодили — в том числе бесконечный цикл — после того как интерпретатор проглотит заданное количество инструкций _(определяемое через `count`)_, он гарантированно передаст управление нашему обработчику, который не менее гарантированно все эти безобразия беспощадно прекратит. Насчёт "беспощадно" — запомним пока, чуть позже к этому моменту придётся вернуться.

Здесь, правда, есть один нюанс — учитываются именно Lua-инструкции выполненные интерпретатором. А вот выполнение С/С++ функций, вызванных из Lua не будет увеличивать счётчик инструкций т.к. интерпретатор Lua в этот момент будет находиться в состоянии ожидания их завершения. Эммм... два нюанса. Второй — если мы уже из обработчика вызовем какой-нибудь Lua-код, то его выполнение тоже не окажет влияния на счётчик инструкций. Правда этот момент нас не сильно колышет до тех пор, пока, не посетит гениальная идея сделать обработчик настолько гибким, что его поведение можно было бы настраивать скриптами.

Сам хук, как и в случае с кастомным аллокатором — всё та же простая C-функция.

```cpp
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
```

Соответственно и ограничения те же, что и с аллокатором — состояние нам тоже придётся хранить во внешней структуре. Но это мы только что проходили, так что здесь проблем быть не должно _[[padme.jpg]]_.

И ставится он тоже в одном экземпляре на Lua-стейт. Поэтому постановку и снятие хука, вкупе с управлением его состоянием логично будет тоже поселить на уровне `LuaRuntime`, а не живущих на нём `LuaSandbox`'ах.

Ну а с идиоматическими способами

```cpp
// генерации ошибок
luaL_error(L, "Timeout guard: Script timed out.");

// и их отлова
auto result = sandbox.runFile(scriptFile);

if (!result.valid()) {
    auto err = sol::error{result};
    std::cerr << err.what();
}
```

мы уже более чем знакомы.

Помните, я про "беспощадность" писал? Так вот, она кроется именно здесь — ненавязчиво напоминаю о том, что при вызове `luaL_error`:
> Происходит перепрыгивание через C++ кадры стека, и деструкторы C++ объектов на этом пути не вызываются.

Это не проблема, просто учитываем данный нюанс при реализации хука и не суём в него ничего, что потребовало бы динамического выделения памяти. Хотя там логика примитивная — тупо проверяем, не закончилось ли время выполнения, и если да, то генерируем ошибку:

```cpp
namespace lua::timeoutGuard
{
    void defaultHook(lua_State *L, lua_Debug* /*ar*/) // второй аргумент не используется
    {
        auto *ctx = static_cast<HookContext*>(ud);
        if (ctx->isTimedOut()) {
            luaL_error(L, "Timeout guard: Script timed out.");
        }
    }
    ...
```

Если где и можно было вляпаться в динамическое выделение памяти, так это только при генерации текста ошибки. Только не спрашивайте зачем.

Весь же механизм его постановки и снятия умещается всего в нескольких строках:

```cpp
    ...
    using InstructionsCount = int; // Просто для улучшения читабельности

    // Постановка
    void setHook(sol::state_view lua,
                 InstructionsCount checkPeriod,
                 lua_Hook func /* = lua::timeoutGuard::defaultHook */)
    {
        assert(checkPeriod > 0 && "Check period must be a positive integer.");
        lua_sethook(lua.lua_state(), func, LUA_MASKCOUNT, checkPeriod);
    }

    // И снятие
    void removeHook(sol::state_view lua)
    {
        lua_sethook(lua.lua_state(), nullptr, 0, 0);
    }
    ...
```    

Ну и контекст, в котором хранится состояние, не менее минималистичен:

```cpp
    ...
    namespace time = std::chrono;

    struct HookContext
    {
        using clock = time::steady_clock;

        clock::time_point deadline{}; // Собственно точка на временном континууме,
                                      // за которую нам нельзя вывалиться
        bool enabled{false};          // Признак того, что таймер запущен

        // Включаем таймер перед запуском подозрительного скрипта...
        void start(time::milliseconds limit)
        {
            enabled = true;
            deadline = clock::now() + limit;
        }

        // ... периодически проверяем не слишком ли много внимания тот к себе хочет.
        bool isTimedOut() { return enabled && clock::now() > deadline; }

        // И сбрасываем таймер после завершения выполнения скрипта,
        // причём не важно, с каким результатом — удачно или с ошибкой.
        // Иначе, если не выгрузим хук, то он всё время будет генерировать ошибку.
        void reset() { *this = HookContext{}; }
    };
} //namespace lua::timeoutGuard
```

Всё.

Или нет? Ошибку заметили?

В отличие от аллокатора, Lua при вызове хука не предоставляет ему указатель на пользовательские данные, и тип указателя нам явно на это намякивает:

```cpp
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
```

```cpp
void defaultHook(lua_State *L, lua_Debug* /*ar*/)
{
    // auto *ctx = static_cast<HookContext*>(ud); < Это не сработает, у нас нет `ud`
    if (ctx->isTimedOut()) {
        luaL_error(L, "Timeout guard: Script timed out.");
    }
}
```

Так что примерно здесь халява с готовыми решениями закончилась, пошли искать варианты на передачу `HookContext` в сам обработчик прерывания.

- В принципе, у нас есть Lua-стейт — можно прямо в него, как Lua-объект. Вот только доступ к нему будет и у скриптов. И даже если сделать его поля read-only через `sol::readonly` или `sol::property`, то мы никак не сможем запретить перезаписать весь объект, плюс попытка записи в read-only поля генерирует ошибку, а это — дополнительный канал для утечки стабильности.
- Лямбду с захватом в качестве хука подсунуть не получится — она просто не преобразуется к указателю на функцию.
- Через глобальную переменную? У нас может быть несколько рантаймов и каждому свой независимый `HookContext` нужен. Помещать в неё контекст текущего рантайма перед активацией защиты по таймауту? А если в соседнем потоке другой рантайм в этот момент крутится? То есть это уже либо делать её `thread_local` и следить за тем, чтобы каждый Lua-стейт дёргался только из одного потока, либо делать глобальный контейнер с контекстами, из которого каждый хук каким-то образом будет выбирать именно свой.
- Ну, либо почитать в конце концов документацию и найти там специально заточенный под это механизм — реестр _(Lua registry)_.

Lua registry — это специальная таблица внутри Lua-стейта, предназначенная для хранения данных на стороне C/C++ кода, и она недоступна обычным Lua-скриптам. 

Плюс ко всему, `sol2` нам ещё и до нельзя упрощает доступ к её элементам:

```cpp
sol::state lua;
// sol::state_view lua(L) // Либо так, если мы, как в случае с хуком, не владеем 
                          // стейтом, но у нас есть аргумент с lua_State *L

lua.registry()[key] = value;        // Запись в реестр
auto value = lua.registry()[key];   // Получение значения из него
```

Ну согласитесь, элегантно же — на голову выше варианта с передачей контекста через глобальные переменные.

Осталась всего одна маленькая, чисто символическая проблемка... передать ключ в функцию... Нда, сильно продвинулись )

Ладно, шучу, на самом деле действительно продвинулись — у нас теперь есть способ передачи контекста актуального для конкретного Lua-стейта. С ключом проще — он может быть одинаковым вообще для всех рантаймов и потоков. Его единственная задача - быть уникальным ~~снежинком~~. Поэтому да, просто глобальная константа. Ну почти.

Начнём с типа. В качестве гарантированно уникального ключа RTFM нам настойчиво рекомендует использовать так называемый light userdata с адресом C/C++ объекта внутри — в `sol2` он реализован под именем `sol::lightuserdata`. А кто мы такие, чтобы перечить мануалу?

Поэтому его мы использовать не будем _(ну он реально тяжеловат для ключа)_, но возьмём упрощённую версию, которая является просто обёрткой над `void *` указателем:

```cpp
struct sol::lightuserdata_value // Да и называется почти так же ))
{
    void* value;
    lightuserdata_value(void* data) : value(data) {}
    operator void*() const { return value; }
};
```

```cpp
namespace lua::registry
{
    using Key = sol::lightuserdata_value;
    ...
```

А в качестве значения ключа будем использовать адрес статической переменной — куда уж уникальней? Ну и сделаем небольшой задел на будущее — вдруг нам ещё какие-то контексты потом понадобятся? Просто немного автоматизируем генерацию таких ключей для различных типов контекстов.

```cpp
    ...
    template <typename Tag>
    struct KeyTag
    {
        inline static char kTag{}; // В чём смысл бытия? В самом существовании.
                                   // Ну и уникальный адрес в качестве сайд-эффекта
        static auto key() -> Key { return Key{&kTag}; }
    };
} // namespace lua::registry
```

Таким образом мы для произвольного типа получаем уникальный ключ. И доступ к нему у нас есть из любого места программы, в том числе из нашего хука-обработчика, ради которого это всё и затевалось. Через такую вот аваду кедавру.

```cpp
auto registryKey = lua::registry::KeyTag<lua::timeoutGuard::HookContext>::key();
```

Ну ладно-ладно, сейчас сократим.

А чтобы два раза не вставать — действительно же потом для похожих задач может понадобиться — добавим один уровень абстракции: `lua::registry::TypeTaggedSlot` — гарантированно уникальная запись в реестре, хранящая указатель на произвольную структуру данных, доступ к которой осуществляется через указание типа этой структуры. То есть мы вообще уходим от ручного использования ключей, пряча их под капотом, и заменяем их типом — вот что система шаблонов животворящая делает. Сейчас на код посмотрим — надеюсь, станет понятней.

И наш многострадальный хук, наконец-то, сможет приобрести законченный и, главное, уже работоспособный вид:

```cpp
namespace lua::timeoutGuard
{
    void defaultHook(lua_State *L, lua_Debug* /*ar*/)
    {
        using Registry = registry::TypeTaggedSlot<HookContext>;

        auto *ctx = Registry::get(L); // Согласитесь — так гораздо лаконичней

        if (ctx == nullptr) {
            luaL_error(L, "Timeout guard: Unable to get hook context.");
        }
        if (ctx->isTimedOut()) {
            luaL_error(L, "Timeout guard: Script timed out.");
        }
    }
} // namespace lua::timeoutGuard
```

Ну а всю работу со слотами реестра упаковываем в `TypeTaggedSlot`. Ещё раз заостряю внимание — внутри храним не сами структуры, а только указатели на них.

```cpp
namespace lua::registry
{
    template <typename Tag, typename DataT = Tag>
    struct TypeTaggedSlot
    {
        using SlotKey = KeyTag<Tag>; // Уникальный для данного типа ключ

        using Stored = sol::lightuserdata_value; // Всё та же обёртка над void *.
        // В данном случае он нам подходит и как тип для value — так как хранить
        // мы будем указатель на структуру данных

        // Создание записи в реестре и помещение туда указателя
        static void set(sol::state_view lua, DataT *data)
        {
            lua.registry()[SlotKey::key()] = Stored{static_cast<void *>(data)};
        }

        // Получение хранимого указателя
        static DataT *get(sol::state_view lua)
        {
            auto data = sol::object{lua.registry()[SlotKey::key()]};

            if (!data.valid() || !data.is<Stored>()) { // проверяем, есть ли вообще
                return nullptr;                        // в реестре такая запись?
            }
            return static_cast<DataT*>(data.as<Stored>().value); // void* -> DataT*
        }

        // И удаление записи из реестра
        static void remove(sol::state_view lua)
        {
            lua.registry()[SlotKey::key()] = sol::nil;
        }

        // Ну и проверка на наличие записи как таковой
        static bool empty(sol::state_view lua) { return get(lua) == nullptr; }
    };
} // namespace lua::registry
```

Всё, вот теперь у нас есть весь инструментарий.

Посмотрим, на него в действии — попробуем запустить скрипт с защитой по таймауту.

```cpp
// Создаём рантайм с песочницей
LuaRuntime lua;
LuaSandbox sandbox(lua, LuaSandbox::Presets::Minimal);

using guardCtxRegistry = lua::registry::TypeTaggedSlot<HookContext>;

// Помещаем контекст в реестр
auto guard = HookContext{};
guardCtxRegistry::set(lua.state, &guard);

// И ставим хук
lua_sethook(lua.state.lua_state(), lua::timeoutGuard, LUA_MASKCOUNT, 10'000);

guard.start(5ms); // Активируем защиту

// Запускаем наш зело подозрительный скрипт
auto result = sandbox.runFile("exceedingly_suspected.lua"); 

guard.reset(); // Деактивируем защиту

if (!result.valid()) {
    auto err = sol::error{result};
    if (contains(err.what(), "Script timed out")) {
        // Обрабатываем эту ошибку
    }
}

...

// Наигрались? Удаляем хук
lua_sethook(lua.state.lua_state(), nullptr, 0, 0);

// И контекст
guardCtxRegistry::remove(lua.state);
```

Нда. Не многовато телодвижений? На мой взгляд — перебор.

Сильно сократить количество действий, конечно, не получится, но автоматизировать можно.

## We need to go deeper (с) Ди Каприо

Во-первых, помещение контекста в реестр и регистрация хука — это те операции, которые прямо просятся сделать их всего один раз, при создании рантайма. Ну ладно, два — их выгрузка из Lua-стейта тоже считается. И в дальнейшем просто оборачивать активацией и сбросом таймера каждый вызов Lua-кода, который мы хотим обезопасить. Но если копнуть чуть глубже, то у нас всё это время будут активными сразу ~~две бомбы~~ два глобальных состояния — сам хук, и запись в реестре. Что если кто-то захочет для какого-то отдельного куска Lua-кода использовать свою пару контекст/обработчик? А ведь хуки можно и для других целей использовать — где гарантия, что кто-нибудь не захочет параллельно воспользоваться этим механизмом? А тут уже просто постановкой и регистрацией не отделаешься — здравствуйте проверки установленного/сохранение/восстановление после использования.

А, ведь, можно ещё глубже зарыться — вложенные вызовы: например, на стороне Lua вызываем безобидную функцию:

```cpp
auto guard = HookContext{};

...

guard.start(5ms); // Активация защиты

auto result = sandbox.run(R"(
    return acceptTheFiefOfArrakis() -- Казалось бы, что может пойти не так?
)");

guard.reset();
...
```

Которая, фактически, является C-функцией, зарегистрированной в рантайме:

```cpp
...
sandbox["acceptTheFiefOfArrakis"] = [&]() -> sol::protectef_function_result {

    guard.start(5ms); // А что у нас здесь с нашей защитой происходит?
                      // Явно не то поведение, которое уровнем выше ожидается.

    auto result = sandbox.runFile("PlansWithinPlansWithinPlans.lua");

    guard.reset();

    if (!result.valid()) {
        ...
    }
    return result;
}
...
```

То есть ещё и, как минимум, на контроль повторной активации таймера налипаем. 

И это мы ещё даже внутрь `.lua`-файла не заглянули. 

И вот, в свете того, что нам сейчас придётся как-то разруливать потенциальные проблемы с глобальными состояниями, которые могут быть изменены где и кем только не, идея с загрузкой контекста и хука перед каждым использованием уже перестаёт восприниматься как нечто иррациональное. И становится даже более чем рациональным после того, как посчитать реальные затраты на загрузку/выгрузку и понять, что они просто ничтожно малы по сравнению с затратами на исполнение самого защищаемого Lua-кода. Ну и добьём тем, что контроль времени выполнения требуется очень далеко не для всего Lua-кода, и даже более — нам никто не мешает реализоваться такую опцию, как "только первый запуск с контролем", после чего скрипт/функция переходит в разряд доверенных.

Поэтому, чтобы сейчас не переусложнять объяснение, есть предложение — на данном этапе остановиться на решении в лоб, а тонкую оптимизацию оставить на потом _(если, конечно, профайлинг(!) покажет (покажет!), что многократные постановки и снятия хука с его контекстом, действительно, дают просадку производительности)_. Кто сказал "технический долг"?

Итак, решение "в лоб":
Каждый запуск Lua-кода с защитой по таймауту предваряется регистрацией контекста и хука, которые выгружаются при завершении. Если хук или контекст уже были установлены — защита не активируется. Но в пределах такого блока оставляем возможность для реактивации таймера — продления его времени действия, чтобы можно было последовательно несколько кусков Lua-кода выполнить.

Напомню, это всё было "во-первых".

## Лучше день потерять, потом за пять минут долететь!

А во-вторых, обещанная автоматизация потребует определённой подготовки.

Для начала обмажемся ещё одним слоем абстракции: `Watchdog`, на плечи которого ляжет рутина по регистрации контекста в реестре, постановка хука и активация таймера, включая проверки естественно. Ну и обратные действия конечно. Кроме того, `Watchdog` у нас будет привязываться к конкретному Lua-стейту.

```cpp
namespace lua::timeoutGuard
{
    constexpr auto kDefaultCheckPeriod {10'000}; // Дефолтный период вызова хука
	constexpr auto kDefaultLimit {5ms};          // Дефолтный таймаут

    class Watchdog
    {
    private:
        lua_State *lua{nullptr};          // Привязка к конкретному Lua-стейту
        InstructionsCount checkPeriod{0}; // Период вызова хука, в кол-ве инструкций
        lua_Hook hook{nullptr};           // Указатель на сам хук
        HookContext context{};            // Ну и его контекст

        bool running{false};              // Признак того, что защита активирована

    public:
        // Алиас регистрового слота для контекста, просто сократим для читабельности
        using CtxRegistry = registry::TypeTaggedSlot<HookContext>;

        // Конструктор, с обязательной привязкой к Lua-стейту
        Watchdog(sol::state_view lua,
                 InstructionsCount checkPeriod = kDefaultCheckPeriod,
                 lua_Hook hookFn = defaultHook)
            : lua(lua),
              checkPeriod(checkPeriod > 0 ? checkPeriod : kDefaultCheckPeriod),
              hook(hookFn)
        {}

        // Отключаем возможность копирования и перемещения во избежание эксцессов
        Watchdog(const Watchdog &) = delete;
        Watchdog &operator=(const Watchdog &) = delete;
        Watchdog(Watchdog &&) = delete;
        Watchdog &operator=(Watchdog &&) = delete;

        // При уничтожении объекта обязательно нужно подчистить за собой Lua-стейт:
        // снять хук, если остался, и выгрузить контекст из реестра
        ~Watchdog() { detach(); }

        // Привязка к Lua-стейту
        bool attach(sol::state_view newLua, bool force = false);

        // И отсоединение от него
        void detach();

        // Изменение параметров хука — можно задать период вызова и саму функцию,
        // которую будем вызывать 
        bool configureHook(InstructionsCount newCheckPeriod, lua_Hook newHook);

        bool armed() { return running; } // Проверка активности защиты
        bool timedOut() { return context.isTimedOut(); } // Проверка сработки

        bool arm(time::milliseconds limit);   // Активация защиты
        bool rearm(time::milliseconds limit); // Используется для продления времени
                                              // действия уже активированной защиты.
        void disarm();                        // Деактивация защиты

    private:
        // Проверка на предмет привязки к какому-нибудь Lua-стейту
        bool attached() { return lua != nullptr; } 
    };
```

```cpp
    // Привязка к Lua-стейту
    bool Watchdog::attach(sol::state_view newLua, bool force /* = false */)
    {
        // Осуществляем привязку только в том случае, если в данный момент защита
        // не активирована. Мы же условились, что активирована она может быть только
        // непосредственно перед выполнением защищаемого Lua-кода, следовательно
        // переключение Lua-стейта сейчас — явно нечто странное.
        if (force) {
            // Но допускаем принудительную перепривязку через соотвествующую опцию
            detach();
        } else if (armed()) {
            std::cerr << "Cannot attach timeout watchdog to a new Lua state while it's armed\n";
            return false;
        }
        lua = newLua;
        return true;
    }

    // Отвязка от текущего Lua-стейта
    void Watchdog::detach()
    {
        disarm();
        lua = nullptr;
    }

    // Задаём параметры хука — период вызова и саму функцию — обработчик.
    // Здесь только задаём значения, в Lua-стейт не ставится!
    bool Watchdog::configureHook(InstructionsCount newCheckPeriod, lua_Hook newHook)
    {
        if (armed()) { // Запрет на изменения если защита взведена
            std::cerr << "Cannot change timeout watchdog hook settings while it's armed\n";
            return false;
        }
        if (newCheckPeriod <= 0) { // Защита от установки ошибочных значений
            std::cerr << "Unable to change timeout watchdog hook settings: "
                         "Check period has to be a positive integer\n";
            return false;
        }
        if (newHook == nullptr) { // Защита от установки ошибочных значений
            std::cerr << "Unable to change timeout watchdog hook settings: "
                         "Hook function pointer cannot be null\n";
            return false;
        }
        checkPeriod = newCheckPeriod;
        hook = newHook;
        return true;
    }

    // Взведение защиты в активное состояние
    bool Watchdog::arm(time::milliseconds limit)
    {
        if (armed()) { // Опять же, защита от повторного взведения
            std::cerr << "Unable to arm timeout watchdog: already armed\n";
            return false;
        }
        if (!attached()) { // Не даём взвестись, если не привязаны к Lua-стейту
            std::cerr << "Unable to arm timeout watchdog: "
                         "Lua state is not properly initialized\n";
            return false;
        }
        // Проверка на незанятость ячейки реестра под контекст
        if (!CtxRegistry::empty(lua)) {
            std::cerr << "Unable to arm timeout watchdog: "
                         "Lua state already has a hook context registered\n";
            return false;
        }
        // Проверка на то, что кто-то другой уже не повесил свой хук
        if (lua_gethook(lua) != nullptr) {
            std::cerr << "Unable to arm timeout watchdog: Lua state already has a hook set\n";
            return false;
        }
        running = true;
        CtxRegistry::set(lua, &context); // Регистрируем контекст
        setHook(lua, checkPeriod, hook); // Ставим хук
        context.start(limit);            // Запускаем таймер
        return true;
    }

    // Принудительное обнуление таймера, для продления его времени действия
    bool Watchdog::rearm(time::milliseconds limit)
    {
        // Работает только если защита была взведена ранее
        if (!armed()) {
            std::cerr << "Unable to rearm timeout watchdog: it is not currently armed\n";
            return false;
        }
        context.start(limit);
        return true;
    }

    // Отключение защиты
    void Watchdog::disarm()
    {
        context.reset(); // Обнуление контекста
        const bool wasArmed = running;
        running = false;

        if (!attached() || !wasArmed) { // В этом случае нам нечего дальше выгружать
            return;
        }
        removeHook(lua); // Выгружаем хук
        CtxRegistry::remove(lua); // и его контекст из реестра
    }
} // namespace lua::timeoutGuard
```

Смотрим, что в итоге получилось:

```cpp
LuaRuntime lua;
LuaSandbox sandbox(lua, LuaSandbox::Presets::Minimal);

auto watchdog = timeout::Watchdog(lua);

watchdog.arm(5ms);

sandbox.runFile("exceedingly_suspected.lua")

if (watchdog.timedOut()) {
    ...
}
watchdog.disarm();
```

Ну что же, можно констатировать, что уже даже более-менее читабельно стало. Разве что ещё `Watchdog` внутрь `LuaRuntime` просится, чтобы вручную его не создавать.

Ну раз просится...

```cpp
class LuaRuntime
{
    ...
public:
	sol::state state; // Опять же, оставил только для фиксации порядка объявления
    ...
private:
    // Дадим ему более конкретное наименование
	lua::timeoutGuard::Watchdog timeoutGuard;

public:
    // И доработаем конструкторы для принудительной инициализации.
	LuaRuntime()
		: state{},
		  timeoutGuard(state) // Гарантированно привязываем его к стейту
	{}

	LuaRuntime(size_t memoryLimit,
               lua::memory::Allocator fn = lua::memory::limitedAlloc)
		: allocatorState({.limit = memoryLimit}),
		  allocatorFn(fn),
		  state(sol::default_at_panic, fn, &allocatorState),
		  timeoutGuard(state) // И здесь
	{}
    ...
    // Остаётся только дополнить reset(), чтобы при создании нового Lua-стейта
    // Watchdog у нас автоматически привязывался к новой инкарнации
    void LuaRuntime::reset()
    {
        ...	
        // Принудительная перепривязка Lua-стейта
        timeoutGuard.attach(state, true); 
    }
};
```

Но и это ещё не всё. _[[(Потерпите, чуть-чуть осталось)]]_

Обратили внимание, что `timeoutGuard` — приватный, и отсутствие геттера делает невозможным его использование снаружи? Дело в том, что и его применение можно автоматизировать.

Отпрыгнем немного в сторону: 

> В C++ имеется механизм конструкторов и деструкторов, которые автоматически вызываются в момент инициализации объектов и при завершении их времени жизни соответственно. Объекты с автоматическим временем хранения уничтожаются автоматически при выходе из блока, в котором они были объявлены.

Понимаете, к чему я клоню? Мы можем создать временный объект и вызовы `arm`/`disarm` поместить в его конструктор с деструктором, и ~~обернуть это всё фигурными скобками~~ поместить его в один блок с вызовом защищаемого Lua-кода:

```cpp
LuaRuntime lua;
LuaSandbox sandbox(lua, LuaSandbox::Presets::Minimal);

// Здесь вызываем доверенный код
sandbox.runFile("trusted_code.lua");

{ // Блок подозрительного кода
    auto scopeGuard = sandbox.makeTimeoutGuardedScope(5ms); // arm() в конструкторе

    sandbox.runFile("exceedingly_suspected.lua")
    if (scopeGuard.timedOut()) {
        ...
    }
    
    // При необходимости, можно прямо здесь следующую порцию Lua-кода запустить
    scopeGuard.rearm(); 

    sandbox["someFunction"](); // Да, с отдельными функциями тоже работает
    if (scopeGuard.timedOut()) {
        ...
    }
} // disarm() в деструкторе scopeGuard
...
```

Ну согласитесь — из-за такого стоит ещё немного поднапрячься ;)

Ну там, правда, чуть-чуть осталось. Итак, `GuardedScope` — обёртка теперь уже над `Watchdog`:

```cpp
namespace lua::timeoutGuard
{
	class GuardedScope
	{
	private:
		Watchdog *watchdog{nullptr}; // Указатель на оборачиваемый Watchdog

	public:
        // Watchdog передаём по ссылке, чтобы гарантировать, что объект существует
		GuardedScope(Watchdog &watchdog, time::milliseconds limit = kDefaultLimit)
			: watchdog(&watchdog)
		{
            // Собственно, то, ради чего всё и затевалось — arm в конструкторе
			if (!watchdog.arm(limit)) {
				disable();
			}
		}
        // Запрещаем копирование
		GuardedScope(const GuardedScope &) = delete;
		GuardedScope &operator=(const GuardedScope &) = delete;

        // А вот move-конструктор пригодится для для фабричных методов
		GuardedScope(GuardedScope &&other) 
            : watchdog(other.watchdog)
        { 
            other.disable(); // Деактивируем источник
        }
		GuardedScope &operator=(GuardedScope &&other) = delete; // тоже удаляем

		// Автоматическая деактивация Watchdog
        ~GuardedScope()
		{
			if (disabled()) {
				return;
			}
			watchdog->disarm();
		}

        // Возможность продления времени действия таймера для последующих
        // порций Lua-кода запускаемых в этом же scope
		bool rearm(time::milliseconds limit = kDefaultLimit)
		{
			if (disabled()) {
				return false;
			}
			return watchdog->rearm(limit);
		}
        // Проверка на сработку
		bool timedOut() { return !disabled() && watchdog->timedOut(); }

	private:
		void disable() { watchdog = nullptr; } // Ну и деактивация 

		bool disabled() { return watchdog == nullptr; } // с соотвествующей проверкой
	};
} // namespace lua::timeoutGuard
```

И последний штрих: добавляем цепочку методов `LuaSandbox -> LuaRuntime` для получения экземпляра `GuardedScope`:

```cpp
auto LuaRuntime::makeTimeoutGuardedScope(std::chrono::milliseconds limit)
    -> lua::timeoutGuard::GuardedScope
{
    return lua::timeoutGuard::GuardedScope{timeoutGuard, limit};
}

auto LuaSandbox::makeTimeoutGuardedScope(std::chrono::milliseconds limit)
    -> lua::timeoutGuard::GuardedScope
{
    return runtime->makeTimeoutGuardedScope(limit);
}
```

Вот теперь точно всё.

## High Score

Ну что, пора подводить итоги?

Lua — безусловно замечательный язык, заслуженно снискавший славу одного из лучших встраиваемых скриптовых языков. Уйма проектов, использующих его для этих целей, причём далеко не только в игрострое, не даст соврать.

Хотелось бы, конечно, иметь возможность просто подключить его к своему движку, ~~нажать кнопку "сделать зае~~ и, выставив несколько отвечающих за изоляцию опций на этапе компиляции, получить готовое решение, полностью нас устраивающее. Да, конечно, есть альтернативные варианты разной степени готовности — например, [Luau](https://luau.org/) — решение от создателей Roblox, но это компромисс ценой частичной потери гибкости и совместимости. Что же касается ванильного Lua, то, к сожалению, пока имеем то, что имеем: приходится пилить изоляцию вручную — слой за слоем, закрывая потенциальные дыры. Этим опусом мы успели охватить основную часть проблем:

1. Изоляция окружения через `sol::environment` и управляемый `_G`, чтобы скрипты не лезли в глобальный стейт напрямую.
2. Явные правила загрузки, _(в том числе частичной)_, библиотек в песочницу.
3. Безопасные замены функций, запускающих модули и файлы со скриптами, с проверкой путей и запретом байткода.
4. Лимиты памяти через кастомный аллокатор.
5. Ограничение времени выполнения с RAII-обёрткой для минимизации ручной рутины.

Из того, что ещё нужно, но не было охвачено:

6. Механизм контроля целостности доверенных скриптов — например, скриптов, поставляемых нами самими. Со скриптами модов пользователь может делать что угодно, но для гарантированной работоспособности движка родные скрипты трогать не стоит.
7. Hotreload — по факту изменений. В общем, логика простая: регистрируем определённые скрипты как требующие горячей перезагрузки, периодически проверяем, не изменились ли эти файлы, и, если да, то перезапускаем их.

Но прежде чем излагать эти решения в виде статьи, деталям реализации ещё нужно выкристаллизоваться. Возможно, как-нибудь потом.

Засим разрешите откланяться. Буду рад, если пригодится.

---

Код в удобоваримой, пригодной к использованию форме можно посмотреть [здесь](https://github.com/ipochto/luaSandboxing/tree/master/src).
